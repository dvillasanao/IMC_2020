# M√©todo de estratificaci√≥n  {.unlisted .unnumbered}

### Identificaci√≥n de datos at√≠picos {-}   

Para hacer cumplir la definici√≥n de los l√≠mites en el m√©todo de estratificaci√≥n [v√©ase: `M√©todo de estratificaci√≥n de Dalenius & Hodges`] y el n√∫mero √≥ptimo de clases basados en la media aritm√©tica, es importante la identificaci√≥n de datos at√≠picos porque podr√≠an ocasionar resultados poco adecuados. Para contrarrestar este problema, `Hubert y Vandervieren (2007)` proponen el m√©todo de caja, el cual toma en cuenta el grado de asimetr√≠a de un conjunto de datos.  

$$\left[Q_{1} - 1.5e^{-4MC} IQR; \hspace{0.5cm}  Q_{3} + 1.5e^{-4MC} IQR \right] \text{para } MC \geq 0$$
$$\left[Q_{1} - 1.5e^{-3MC} IQR; \hspace{0.5cm}  Q_{3} + 1.5e^{-3MC} IQR \right] \text{para } MC < 0$$
donde:   
$\circ \:ùëÑ_{1}$ ùë¶ $ùëÑ_{3}$: hacen referencia al primer y tercer cuartil, respectivamente; la diferencia entre estos dos valores da como resultado el valor de espacio intercuartil ($ùêºùëÑùëÖ$), y    
$\circ \:ùëÄùê∂ (ùëöùëíùëëùëêùëúùë¢ùëùùëôùëí)$: cuantifica el grado de asimetr√≠a de una muestra univariable ${ùë•_1,ùë•_2,‚Ä¶ ,ùë•_ùëõ}$.     

Se identifican los valores at√≠picos para cada conjunto de datos. 

- Se calculan los estad√≠sticos de la columna del √≠ndice de marginaci√≥n para cada conjunto de datos $DP2_{i}$ correspondientes al a√±o y se asigna el resultado a una nueva variable denominada $outliers_i$.    

```{r}
assign(paste0("outliers_2020"), boxplot.stats(DP2_2020[,24]))
```

Se crea un data.frame que contiene el n√∫mero de valores at√≠picos, su rango y el l√≠mite inferior para cada conjunto de datos.

```{r, echo = FALSE}
#L√≠mites para el c√°lculo de estratificaci√≥n a nivel localidad, 2020
p <- data.frame(n = length(outliers_2020$out), 
                rango = range(outliers_2020$out), 
                lim = outliers_2020$stats[1])
```

```{r, echo = FALSE}
tabla <- data.frame(outliers = p$n[1],
                    minimo = p$rango[1],
                    maximo = p$rango[2])   
tabla %>% 
 gt() %>%
   tab_header(title = "L√≠mites para el c√°lculo de estratificaci√≥n a nivel colonia, 2020") %>%
    fmt_number(columns = c(2:3), decimals = 3) %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = 'Century Gothic',
                table.align = "center",
                table.font.size = 10,
                data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
                locations = list(cells_title(groups = c("subtitle")))) %>%  
      cols_label(outliers = md("**Valores at√≠picos**"), 
                minimo = md("**M√≠nimo**"),
                maximo = md("**L√≠mite**")) %>%
       tab_spanner(label = "Rango",
                   columns = c(minimo, maximo)) %>%
         as_raw_html() 

```

Se identifican los casos extremos en el √≠ndice de marginaci√≥n y se aplica el m√©todo de caja propuesto por `Hubert y Vandervieren`, concluyendo los l√≠mites con los que se debe trabajar.      

Se a√±ade una nueva columna `IM_out`. Esta columna se calcula usando `if_else`, de la siguiente manera:   

- Si el valor de IM es mayor o igual al l√≠mite inferior de los valores no considerados outliers `(get(paste0("outliers_", i))$stats[1])`, entonces `IM_out` toma el valor de `IM`.   
- Si el valor de IM es menor que el l√≠mite inferior, entonces `IM_out` toma el valor del l√≠mite inferior, eliminando as√≠ los outliers.      


```{r}
## Se crea un √≠ndice ficticio, en la que se quitan los outliers   
DP2_2020 <- DP2_2020 %>%
             mutate(IM_out = ifelse(get(paste(colnames(DP2_2020))[24]) >= outliers_2020$stats[1],
                                    get(paste(colnames(DP2_2020))[24]),
                                    outliers_2020$stats[1]))
```


### M√©todo de estratificaci√≥n de Dalenius & Hodges {-}

`strata.cumrootf`: cumulative root frequency method by Dalenius and Hodges (1959). 

Con la obtenci√≥n del √≠ndice de marginaci√≥n a trav√©s del m√©todo DP2, los valores se clasificaron en cinco categor√≠as ordinales con el m√©todo de Dalenius y Hodges (1959), para obtener el grado de marginaci√≥n. Este m√©todo forma estratos de manera que la varianza sea m√≠nima al interior de cada estrato y m√°xima entre cada uno de ellos, es decir, son lo m√°s homog√©neos posibles. Este procedimiento utiliza la ra√≠z de las frecuencias acumuladas para la construcci√≥n de los estratos, por lo que se lleva a cabo para la divisi√≥n de la poblaci√≥n en el estrato L. Esta es una soluci√≥n aproximada de Dalenius y Hodges (1959) a las ecuaciones de Dalenius (1950). De acuerdo con Gunning y Horgan (2004), el l√≠mite superior de cada estrato se determin√≥ con la siguiente expresi√≥n:  

$$Q = \frac{1}{L}\sum^{J}_{i=1}{\sqrt{f_{i}}}$$

Sea un conjunto de estratos determinados por su l√≠mite superior,

 $$Q,\ 2Q,\ \ldots,\ \left(L-1\right)Q,\ (L)Q.$$
donde:  

$\circ \:J$: es el n√∫mero de clases dentro del grupo de la variable ordenada X,    
$\circ \:f_{i}\ \in(1,\ \ldots, J)$: es la frecuencia en cada clase  $J$, y  
$\circ \:L$: es el n√∫mero de estratos.   


La eficiencia del m√©todo de la ra√≠z de las frecuencias acumuladas depende principalmente del n√∫mero de clases dentro del grupo de la variable ordenada. Sin embargo, no hay un procedimiento est√°ndar sobre c√≥mo elegir el mejor valor para el n√∫mero de clases, siendo esto una limitante del m√©todo de Dalenius y Hodges. Para medir el efecto del n√∫mero  de clases en la varianza de cada estrato se recurri√≥ a un m√©todo iterativo para obtener un criterio de agrupaci√≥n √≥ptimo.    

Para establecer los l√≠mites de los estratos $(b_{1},\ \ldots,\ b_{L})$ que minimicen la varianza del estimador, se utiliza la asignaci√≥n de Neyman para determinar el tama√±o de muestra √≥ptimo. Sea la varianza del estimador:    

$$V\left({\bar{x}}_{st}\right)=\ \sum_{h}\left(\frac{N_h}{N}\right)^2\frac{S_h^2}{n_h}\ $$
donde:

$\circ  \: S_{h}^{2}$: es la varianza poblacional en el estrato $h$,   
$\circ  \:n_{h}$: es el tama√±o de muestra en el estrato $h$ utilizada por la asignaci√≥n de Neyman, y 
$\circ  \:N_{h}$: es el total de elementos en el estrato $h$, sea $N=\sum_{h=1}^{L}{N_{h}}$.     

Si se asume que la distribuci√≥n dentro de cada estrato se distribuye aproximadamente de manera uniforme, los l√≠mites se obtienen tomando intervalos iguales en la funci√≥n de la ra√≠z de las frecuencias acumuladas. Los l√≠mites se resuelven de manera iterativa:   

$$\frac{S_h^2+(b_h-{\bar{X}}_h)2}{S_h}=\frac{S_{h+1}^2+(b_h-{\bar{X}}_{h+1})2}{S_{h+1}}\ para\ h=1,\ \ldots.\ ,\ L-1$$
donde:

$\circ  \: b_{h}$: es el l√≠mite superior en el estrato $h$,   
$\circ  \: {\bar{X}}_{h}$: es la media poblacional en el estrato $h$, y   
$\circ  \: S_{h}^{2}$: es la varianza poblacional en el estrato $h$.      

El requisito de precisi√≥n, generalmente se establece cuando el coeficiente de variaci√≥n sea igual a un nivel especificado entre 1 y 10 por ciento (Hidiroglou y Kozak, 2018).     

## N√∫mero √≥ptimo de clases del m√©todo de Dalenius & Hodge {-}  

`alloc` lista que especifica el esquema de asignaci√≥n. La lista debe contener 3 n√∫meros para los 3 exponentes q1, q2 y q3 en el esquema de asignaci√≥n general (ver paquete de `stratification`). El valor predeterminado es la asignaci√≥n de **Neyman** (q1 = q3 = 0.5 y q2 = 0)   

A continuaci√≥n, se realiza un an√°lisis de estratificaci√≥n sobre los diferentes a√±os, usando la funci√≥n `strata.cumrootf()`, almacenando los resultados de errores est√°ndar, medias y varianzas en matrices que luego se guardan en listas.   

```{r, results=FALSE, warning=FALSE, eval = FALSE}
iteraciones <- 1000
start.time <- Sys.time()
i <- 1
sd <- matrix(NA, nrow = (iteraciones), ncol = 3)
meanh <- matrix(NA, nrow = (iteraciones), ncol = 6)
varh <- matrix(NA, nrow = (iteraciones), ncol = 6)
for (n in seq(5, iteraciones, 1)){
     cum <- strata.cumrootf(x = DP2_2020[,25], CV = 0.05 , Ls = 5, alloc = c(0.5, 0, 0.5), nclass = n)
     sd[i,] <-  c(n, cum$stderr, cum$CV)
     meanh[i,] <- c(n, cum$meanh)
     varh[i,] <-  c(n, cum$varh)
     i <- i + 1
  }
colnames(sd) <- c("n", "sderr", "CV")
colnames(meanh) <- c("nclass", paste0(rep("Strata", 5), 1:5))
colnames(varh) <- c("nclass", paste0(rep("Strata", 5), 1:5))
end.time <- Sys.time()
time.taken <- round(end.time - start.time, 2)
time.taken
```

```{r, echo = FALSE}
#saveRDS(sd, file = paste0(here::here(), "/Output/sd.RDS"))
sd <- readRDS(file = paste0(here::here(), "/Output/sd.RDS"))
```

#### N√∫mero √≥ptimo de clases {-}

Se toma cada matriz resultante de errores est√°ndar de la lista `stderr`, y luego selecciona la fila que tiene el coeficiente de variaci√≥n (`CV`) m√°s bajo. Estos resultados se almacenan en la lista `min.strata`, la cual contendr√° los data.frames correspondientes a las filas con el menor `CV `para cada uno de los tres conjuntos de datos en `stderr`.  

```{r}
min.strata <- sd %>%
               as.data.frame() %>% 
                slice(which.min(.$CV)) 
```

```{r, echo = FALSE}
tabla <- min.strata %>%
          dplyr::mutate(ANIO = "2020") %>%
           relocate(ANIO, .before = "n")

tabla %>% 
 rename("A√ëO" = "ANIO") %>%
  gt() %>%
   tab_header(title = "N√∫mero √≥ptimo de clases") %>%
    fmt_integer(columns = names(tabla)[2]) %>%
     fmt_number(columns = names(tabla)[3:4],
                decimals = 2) %>%
       tab_options(heading.title.font.size = 14, 
                   heading.subtitle.font.size = 12,
                   table.font.names = 'Century Gothic',
                   table.align = "center",
                   table.font.size = 10) %>%
        tab_style(style = list(cell_text(align = "left",
                                          weight = 'bold')),
                   locations = list(cells_title(groups = c("title")))) %>%
         tab_style(style = list(cell_text(align = "left")),
                    locations = list(cells_title(groups = c("subtitle")))) %>%
          cols_label(A√ëO = md("**A√ëO**"),
                     n = md("**n**"),
                     sderr = md("**sd**"),
                     CV = md("**C.V.**")) %>%
           as_raw_html() 
```



```{r, echo = FALSE, results=FALSE, out.width='80%'}
p <- sd %>%
      as.data.frame() %>% 
       na.omit() %>%
        arrange(desc(.$CV)) %>%
         ggplot() + 
          geom_point(aes(x = seq(1, nrow(sd %>% na.omit())), y = CV)) + 
           geom_line(aes(x = seq(1, nrow(sd %>% na.omit())), y = CV)) +
            geom_hline(data = min.strata, aes (yintercept = CV), color = "red") +
             geom_text(data = min.strata, aes(label = paste0("CV = ", round(CV, 4)), x = iteraciones - 75, y = CV),  
                       vjust = -1,
                        size = 6,
                         color = "red",
                          family = "Century Gothic") +
             geom_hline(data = min.strata, aes(yintercept = CV), color = "red") +
              theme_minimal() + 
               theme(title = element_text(family = "Century Gothic"), 
                      plot.title = element_text(size = 22, family = "Century Gothic"),
                          plot.subtitle = element_text(size = 20, family = "Century Gothic"),
                          axis.text = element_text(size = 14, family = "Century Gothic"),
                          axis.title = element_text(size = 18, family = "Century Gothic")) + 
                     scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
                 labs(title = "Coeficiente de variaci√≥n √≥ptimo",
                       subtitle = '2020',
                        y = "CV", 
                         x = "iteraciones") 
```


<a href="https://raw.githubusercontent.com/dvillasanao/IMC_2020/main/img/iteraciones.png" data-lightbox="image-1" data-title="iteraciones">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
knitr::include_graphics(paste0(here::here(), "/img/iteraciones.png"))
```
</a>

Se toman en cuenta el n√∫mero de clases que salen del los resultados del m√©todo iterativo. Utilizando la funci√≥n `strata.cumrootf()` de la paqueter√≠a `stratification` con par√°metros espec√≠ficos y el n√∫mero de clases (`nclass`) obtenido de `min.strata`.       
- `CV = 0.05`: Establece el coeficiente de variaci√≥n.   
- `Ls = 5`: Establece el n√∫mero de estratos.   
- `alloc = c(0.5, 0, 0.5)`: Define la asignaci√≥n para la estratificaci√≥n.    
- `nclass = min.strata[,1]`: Establece el n√∫mero de clases utilizando el primer valor de la fila con el menor CV en `min.strata`.  

```{r}
strata.DP2 <- strata.cumrootf(DP2_2020[,25], 
                               CV = 0.01, 
                                Ls = 5, 
                                 alloc = c(0.5, 0, 0.5), 
                                  nclass = min.strata[,1])
```

Se agregan los datos a la base original

```{r}
##Se agrega a la base DP2
DP2_2020 <- data.frame(DP2_2020 %>% 
                        select(-IM_out), ## Se elimina el √≠ndice ficticio
                         strata.DP2[["stratumID"]])

# Se cambian los nombres de las columnas 
names(DP2_2020) <- c(names(DP2_2020)[1:23],
                      paste0("IM_2020"), paste0("GM_2020"))

# Se cambian los levels a los grados de marginaci√≥n correspondientes
levels(DP2_2020[,25]) = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")
```


### L√≠mites de los estratos {-}

Se crea un data frame llamado `limites` que contiene los l√≠mites de ciertos intervalos para el a√±o `2020`. Cada columna contiene una combinaci√≥n de:   
- El valor m√≠nimo del √≠ndice de marginaci√≥n (`IM:`) para el a√±o correspondiente.  
- Los valores de los l√≠mites de los estratos (`bh`) calculados previamente.  
- El valor m√°ximo del √≠ndice de marginaci√≥n (`IM_`) para el a√±o correspondiente.  

```{r}
limites <- data.frame("2020" = c(min(DP2_2020$IM_2020), strata.DP2$bh, max(DP2_2020$IM_2020)))
```


```{r, echo = FALSE}
tabla <- limites %>%
          t()  %>%
           as.data.frame() %>%
            mutate_if(is.numeric, round, digits = 2) %>%
             tibble::rownames_to_column(.data = .) %>% 
              mutate(ANIO = c("2020"),
                     `Muy alto` = paste("[", V1, "-", V2, "]"),
                     `Alto` = paste("(", V2, "-", V3, "]"),
                     `Medio` = paste("(", V3, "-", V4, "]"),
                     `Bajo` = paste("(", V4, "-", V5, "]"),
                     `Muy bajo` = paste("(", V5, "-", V6, "]")) %>%
               select(., c(8:13))

tabla %>% 
 rename("A√ëO" = "ANIO") %>%
  gt(rowname_col = c("A√ëO")) %>%
   tab_header(title = "L√≠mite de los estratos") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10) %>%
     tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
      cols_label(A√ëO = md("**A√ëO**"), 
                 `Muy alto` = md("**Muy alto**"),
                 `Alto` = md("**Alto**"),
                 `Medio` = md("**Medio**"),
                 `Bajo` = md("**Bajo**"),
                 `Muy bajo` = md("**Muy bajo**")) %>%
      as_raw_html() 
```


