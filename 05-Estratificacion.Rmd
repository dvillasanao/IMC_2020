# Mﾃｩtodo de estratificaciﾃｳn  {.unlisted .unnumbered}

### Identificaciﾃｳn de datos atﾃｭpicos {-}   

Para hacer cumplir la definiciﾃｳn de los lﾃｭmites en el mﾃｩtodo de estratificaciﾃｳn [vﾃｩase: `Mﾃｩtodo de estratificaciﾃｳn de Dalenius & Hodges`] y el nﾃｺmero ﾃｳptimo de clases basados en la media aritmﾃｩtica, es importante la identificaciﾃｳn de datos atﾃｭpicos porque podrﾃｭan ocasionar resultados poco adecuados. Para contrarrestar este problema, `Hubert y Vandervieren (2007)` proponen el mﾃｩtodo de caja, el cual toma en cuenta el grado de asimetrﾃｭa de un conjunto de datos.  

$$\left[Q_{1} - 1.5e^{-4MC} IQR; \hspace{0.5cm}  Q_{3} + 1.5e^{-4MC} IQR \right] \text{para } MC \geq 0$$
$$\left[Q_{1} - 1.5e^{-3MC} IQR; \hspace{0.5cm}  Q_{3} + 1.5e^{-3MC} IQR \right] \text{para } MC < 0$$
donde:   
$\circ \:搗Ю{1}$ 搗ｦ $搗Ю{3}$: hacen referencia al primer y tercer cuartil, respectivamente; la diferencia entre estos dos valores da como resultado el valor de espacio intercuartil ($攝ｼ搗搗$), y    
$\circ \:搗攝ｶ (搗夸搗挺搗択搗栓搗懺搗｢搗晰搗咀搗)$: cuantifica el grado de asimetrﾃｭa de una muestra univariable ${搗･_1,搗･_2,窶ｦ ,搗･_搗孺$.     

Se identifican los valores atﾃｭpicos para cada conjunto de datos. 

- Se calculan los estadﾃｭsticos de la columna del ﾃｭndice de marginaciﾃｳn para cada conjunto de datos $DP2_{i}$ correspondientes al aﾃｱo y se asigna el resultado a una nueva variable denominada $outliers_i$.    

```{r}
assign(paste0("outliers_2020"), boxplot.stats(DP2_2020[,24]))
```

Se crea un data.frame que contiene el nﾃｺmero de valores atﾃｭpicos, su rango y el lﾃｭmite inferior para cada conjunto de datos.

```{r, echo = FALSE}
#Lﾃｭmites para el cﾃ｡lculo de estratificaciﾃｳn a nivel localidad, 2020
p <- data.frame(n = length(outliers_2020$out), 
                rango = range(outliers_2020$out), 
                lim = outliers_2020$stats[1])
```

```{r, echo = FALSE}
tabla <- data.frame(outliers = p$n[1],
                    minimo = p$rango[1],
                    maximo = p$rango[2])   
tabla %>% 
 gt() %>%
   tab_header(title = "Lﾃｭmites para el cﾃ｡lculo de estratificaciﾃｳn a nivel colonia, 2020") %>%
    fmt_number(columns = c(2:3), decimals = 3) %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = 'Century Gothic',
                table.align = "center",
                table.font.size = 10,
                data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
                locations = list(cells_title(groups = c("subtitle")))) %>%  
      cols_label(outliers = md("**Valores atﾃｭpicos**"), 
                minimo = md("**Mﾃｭnimo**"),
                maximo = md("**Lﾃｭmite**")) %>%
       tab_spanner(label = "Rango",
                   columns = c(minimo, maximo)) %>%
         as_raw_html() 

```

Se identifican los casos extremos en el ﾃｭndice de marginaciﾃｳn y se aplica el mﾃｩtodo de caja propuesto por `Hubert y Vandervieren`, concluyendo los lﾃｭmites con los que se debe trabajar.      

Se aﾃｱade una nueva columna `IM_out`. Esta columna se calcula usando `if_else`, de la siguiente manera:   

- Si el valor de IM es mayor o igual al lﾃｭmite inferior de los valores no considerados outliers `(get(paste0("outliers_", i))$stats[1])`, entonces `IM_out` toma el valor de `IM`.   
- Si el valor de IM es menor que el lﾃｭmite inferior, entonces `IM_out` toma el valor del lﾃｭmite inferior, eliminando asﾃｭ los outliers.      


```{r}
## Se crea un ﾃｭndice ficticio, en la que se quitan los outliers   
DP2_2020 <- DP2_2020 %>%
             mutate(IM_out = ifelse(get(paste(colnames(DP2_2020))[24]) >= outliers_2020$stats[1],
                                    get(paste(colnames(DP2_2020))[24]),
                                    outliers_2020$stats[1]))
```


### Mﾃｩtodo de estratificaciﾃｳn de Dalenius & Hodges {-}

`strata.cumrootf`: cumulative root frequency method by Dalenius and Hodges (1959). 

Con la obtenciﾃｳn del ﾃｭndice de marginaciﾃｳn a travﾃｩs del mﾃｩtodo DP2, los valores se clasificaron en cinco categorﾃｭas ordinales con el mﾃｩtodo de Dalenius y Hodges (1959), para obtener el grado de marginaciﾃｳn. Este mﾃｩtodo forma estratos de manera que la varianza sea mﾃｭnima al interior de cada estrato y mﾃ｡xima entre cada uno de ellos, es decir, son lo mﾃ｡s homogﾃｩneos posibles. Este procedimiento utiliza la raﾃｭz de las frecuencias acumuladas para la construcciﾃｳn de los estratos, por lo que se lleva a cabo para la divisiﾃｳn de la poblaciﾃｳn en el estrato L. Esta es una soluciﾃｳn aproximada de Dalenius y Hodges (1959) a las ecuaciones de Dalenius (1950). De acuerdo con Gunning y Horgan (2004), el lﾃｭmite superior de cada estrato se determinﾃｳ con la siguiente expresiﾃｳn:  

$$Q = \frac{1}{L}\sum^{J}_{i=1}{\sqrt{f_{i}}}$$

Sea un conjunto de estratos determinados por su lﾃｭmite superior,

 $$Q,\ 2Q,\ \ldots,\ \left(L-1\right)Q,\ (L)Q.$$
donde:  

$\circ \:J$: es el nﾃｺmero de clases dentro del grupo de la variable ordenada X,    
$\circ \:f_{i}\ \in(1,\ \ldots, J)$: es la frecuencia en cada clase  $J$, y  
$\circ \:L$: es el nﾃｺmero de estratos.   


La eficiencia del mﾃｩtodo de la raﾃｭz de las frecuencias acumuladas depende principalmente del nﾃｺmero de clases dentro del grupo de la variable ordenada. Sin embargo, no hay un procedimiento estﾃ｡ndar sobre cﾃｳmo elegir el mejor valor para el nﾃｺmero de clases, siendo esto una limitante del mﾃｩtodo de Dalenius y Hodges. Para medir el efecto del nﾃｺmero  de clases en la varianza de cada estrato se recurriﾃｳ a un mﾃｩtodo iterativo para obtener un criterio de agrupaciﾃｳn ﾃｳptimo.    

Para establecer los lﾃｭmites de los estratos $(b_{1},\ \ldots,\ b_{L})$ que minimicen la varianza del estimador, se utiliza la asignaciﾃｳn de Neyman para determinar el tamaﾃｱo de muestra ﾃｳptimo. Sea la varianza del estimador:    

$$V\left({\bar{x}}_{st}\right)=\ \sum_{h}\left(\frac{N_h}{N}\right)^2\frac{S_h^2}{n_h}\ $$
donde:

$\circ  \: S_{h}^{2}$: es la varianza poblacional en el estrato $h$,   
$\circ  \:n_{h}$: es el tamaﾃｱo de muestra en el estrato $h$ utilizada por la asignaciﾃｳn de Neyman, y 
$\circ  \:N_{h}$: es el total de elementos en el estrato $h$, sea $N=\sum_{h=1}^{L}{N_{h}}$.     

Si se asume que la distribuciﾃｳn dentro de cada estrato se distribuye aproximadamente de manera uniforme, los lﾃｭmites se obtienen tomando intervalos iguales en la funciﾃｳn de la raﾃｭz de las frecuencias acumuladas. Los lﾃｭmites se resuelven de manera iterativa:   

$$\frac{S_h^2+(b_h-{\bar{X}}_h)2}{S_h}=\frac{S_{h+1}^2+(b_h-{\bar{X}}_{h+1})2}{S_{h+1}}\ para\ h=1,\ \ldots.\ ,\ L-1$$
donde:

$\circ  \: b_{h}$: es el lﾃｭmite superior en el estrato $h$,   
$\circ  \: {\bar{X}}_{h}$: es la media poblacional en el estrato $h$, y   
$\circ  \: S_{h}^{2}$: es la varianza poblacional en el estrato $h$.      

El requisito de precisiﾃｳn, generalmente se establece cuando el coeficiente de variaciﾃｳn sea igual a un nivel especificado entre 1 y 10 por ciento (Hidiroglou y Kozak, 2018).     

## Nﾃｺmero ﾃｳptimo de clases del mﾃｩtodo de Dalenius & Hodge {-}  

`alloc` lista que especifica el esquema de asignaciﾃｳn. La lista debe contener 3 nﾃｺmeros para los 3 exponentes q1, q2 y q3 en el esquema de asignaciﾃｳn general (ver paquete de `stratification`). El valor predeterminado es la asignaciﾃｳn de **Neyman** (q1 = q3 = 0.5 y q2 = 0)   

A continuaciﾃｳn, se realiza un anﾃ｡lisis de estratificaciﾃｳn sobre los diferentes aﾃｱos, usando la funciﾃｳn `strata.cumrootf()`, almacenando los resultados de errores estﾃ｡ndar, medias y varianzas en matrices que luego se guardan en listas.   

```{r, results=FALSE, warning=FALSE, eval = FALSE}
iteraciones <- 1000
start.time <- Sys.time()
i <- 1
sd <- matrix(NA, nrow = (iteraciones), ncol = 3)
meanh <- matrix(NA, nrow = (iteraciones), ncol = 6)
varh <- matrix(NA, nrow = (iteraciones), ncol = 6)
for (n in seq(5, iteraciones, 1)){
     cum <- strata.cumrootf(x = DP2_2020[,25], CV = 0.05 , Ls = 5, alloc = c(0.5, 0, 0.5), nclass = n)
     sd[i,] <-  c(n, cum$stderr, cum$CV)
     meanh[i,] <- c(n, cum$meanh)
     varh[i,] <-  c(n, cum$varh)
     i <- i + 1
  }
colnames(sd) <- c("n", "sderr", "CV")
colnames(meanh) <- c("nclass", paste0(rep("Strata", 5), 1:5))
colnames(varh) <- c("nclass", paste0(rep("Strata", 5), 1:5))
end.time <- Sys.time()
time.taken <- round(end.time - start.time, 2)
time.taken
```

```{r, echo = FALSE}
#saveRDS(sd, file = paste0(here::here(), "/Output/sd.RDS"))
sd <- readRDS(file = paste0(here::here(), "/Output/sd.RDS"))
```

#### Nﾃｺmero ﾃｳptimo de clases {-}

Se toma cada matriz resultante de errores estﾃ｡ndar de la lista `stderr`, y luego selecciona la fila que tiene el coeficiente de variaciﾃｳn (`CV`) mﾃ｡s bajo. Estos resultados se almacenan en la lista `min.strata`, la cual contendrﾃ｡ los data.frames correspondientes a las filas con el menor `CV `para cada uno de los tres conjuntos de datos en `stderr`.  

```{r}
min.strata <- sd %>%
               as.data.frame() %>% 
                slice(which.min(.$CV)) 
```

```{r, echo = FALSE}
tabla <- min.strata %>%
          dplyr::mutate(ANIO = "2020") %>%
           relocate(ANIO, .before = "n")

tabla %>% 
 rename("Aﾃ前" = "ANIO") %>%
  gt() %>%
   tab_header(title = "Nﾃｺmero ﾃｳptimo de clases") %>%
    fmt_integer(columns = names(tabla)[2]) %>%
     fmt_number(columns = names(tabla)[3:4],
                decimals = 2) %>%
       tab_options(heading.title.font.size = 14, 
                   heading.subtitle.font.size = 12,
                   table.font.names = 'Century Gothic',
                   table.align = "center",
                   table.font.size = 10) %>%
        tab_style(style = list(cell_text(align = "left",
                                          weight = 'bold')),
                   locations = list(cells_title(groups = c("title")))) %>%
         tab_style(style = list(cell_text(align = "left")),
                    locations = list(cells_title(groups = c("subtitle")))) %>%
          cols_label(Aﾃ前 = md("**Aﾃ前**"),
                     n = md("**n**"),
                     sderr = md("**sd**"),
                     CV = md("**C.V.**")) %>%
           as_raw_html() 
```



```{r, echo = FALSE, results=FALSE, out.width='80%'}
p <- sd %>%
      as.data.frame() %>% 
       na.omit() %>%
        arrange(desc(.$CV)) %>%
         ggplot() + 
          geom_point(aes(x = seq(1, nrow(sd %>% na.omit())), y = CV)) + 
           geom_line(aes(x = seq(1, nrow(sd %>% na.omit())), y = CV)) +
            geom_hline(data = min.strata, aes (yintercept = CV), color = "red") +
             geom_text(data = min.strata, aes(label = paste0("CV = ", round(CV, 4)), x = iteraciones - 75, y = CV),  
                       vjust = -1,
                        size = 6,
                         color = "red",
                          family = "Century Gothic") +
             geom_hline(data = min.strata, aes(yintercept = CV), color = "red") +
              theme_minimal() + 
               theme(title = element_text(family = "Century Gothic"), 
                      plot.title = element_text(size = 22, family = "Century Gothic"),
                          plot.subtitle = element_text(size = 20, family = "Century Gothic"),
                          axis.text = element_text(size = 14, family = "Century Gothic"),
                          axis.title = element_text(size = 18, family = "Century Gothic")) + 
                     scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
                 labs(title = "Coeficiente de variaciﾃｳn ﾃｳptimo",
                       subtitle = '2020',
                        y = "CV", 
                         x = "iteraciones") 
```


<a href="https://raw.githubusercontent.com/dvillasanao/IMC_2020/main/img/iteraciones.png" data-lightbox="image-1" data-title="iteraciones">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
knitr::include_graphics(paste0(here::here(), "/img/iteraciones.png"))
```
</a>

Se toman en cuenta el nﾃｺmero de clases que salen del los resultados del mﾃｩtodo iterativo. Utilizando la funciﾃｳn `strata.cumrootf()` de la paqueterﾃｭa `stratification` con parﾃ｡metros especﾃｭficos y el nﾃｺmero de clases (`nclass`) obtenido de `min.strata`.       
- `CV = 0.05`: Establece el coeficiente de variaciﾃｳn.   
- `Ls = 5`: Establece el nﾃｺmero de estratos.   
- `alloc = c(0.5, 0, 0.5)`: Define la asignaciﾃｳn para la estratificaciﾃｳn.    
- `nclass = min.strata[,1]`: Establece el nﾃｺmero de clases utilizando el primer valor de la fila con el menor CV en `min.strata`.  

```{r}
strata.DP2 <- strata.cumrootf(DP2_2020[,25], 
                               CV = 0.01, 
                                Ls = 5, 
                                 alloc = c(0.5, 0, 0.5), 
                                  nclass = min.strata[,1])
```

Se agregan los datos a la base original

```{r}
##Se agrega a la base DP2
DP2_2020 <- data.frame(DP2_2020 %>% 
                        select(-IM_out), ## Se elimina el ﾃｭndice ficticio
                         strata.DP2[["stratumID"]])

# Se cambian los nombres de las columnas 
names(DP2_2020) <- c(names(DP2_2020)[1:23],
                      paste0("IM_2020"), paste0("GM_2020"))

# Se cambian los levels a los grados de marginaciﾃｳn correspondientes
levels(DP2_2020[,25]) = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")
```


### Lﾃｭmites de los estratos {-}

Se crea un data frame llamado `limites` que contiene los lﾃｭmites de ciertos intervalos para el aﾃｱo `2020`. Cada columna contiene una combinaciﾃｳn de:   
- El valor mﾃｭnimo del ﾃｭndice de marginaciﾃｳn (`IM:`) para el aﾃｱo correspondiente.  
- Los valores de los lﾃｭmites de los estratos (`bh`) calculados previamente.  
- El valor mﾃ｡ximo del ﾃｭndice de marginaciﾃｳn (`IM_`) para el aﾃｱo correspondiente.  

```{r}
limites <- data.frame("2020" = c(min(DP2_2020$IM_2020), strata.DP2$bh, max(DP2_2020$IM_2020)))
```


```{r, echo = FALSE}
tabla <- limites %>%
          t()  %>%
           as.data.frame() %>%
            mutate_if(is.numeric, round, digits = 2) %>%
             tibble::rownames_to_column(.data = .) %>% 
              mutate(ANIO = c("2020"),
                     `Muy alto` = paste("[", V1, "-", V2, "]"),
                     `Alto` = paste("(", V2, "-", V3, "]"),
                     `Medio` = paste("(", V3, "-", V4, "]"),
                     `Bajo` = paste("(", V4, "-", V5, "]"),
                     `Muy bajo` = paste("(", V5, "-", V6, "]")) %>%
               select(., c(8:13))

tabla %>% 
 rename("Aﾃ前" = "ANIO") %>%
  gt(rowname_col = c("Aﾃ前")) %>%
   tab_header(title = "Lﾃｭmite de los estratos") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10) %>%
     tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
      cols_label(Aﾃ前 = md("**Aﾃ前**"), 
                 `Muy alto` = md("**Muy alto**"),
                 `Alto` = md("**Alto**"),
                 `Medio` = md("**Medio**"),
                 `Bajo` = md("**Bajo**"),
                 `Muy bajo` = md("**Muy bajo**")) %>%
      as_raw_html() 
```


