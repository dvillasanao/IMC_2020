--- 
title: "√çndice de marginaci√≥n a nivel colonia 2020"
author: "Diana Villasana Ocampo"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
url: 'https://github.com/dvillasanao/IMC_2020'
# cover-image: path to the social sharing image like images/cover.jpg
description: |
  This is a minimal example of using the bookdown package to write a book.
  The HTML output format for this example is bookdown::bs4_book,
  set in the _output.yml file.
biblio-style: apalike
csl: chicago-fullnote-bibliography.csl
---
```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```

# √çndice de marginaci√≥n a nivel colonia  {.unlisted .unnumbered}

El √≠ndice de marginaci√≥n a nivel de colonia urbana, elaborado por el Consejo Nacional de Poblaci√≥n (CONAPO) en M√©xico, es una herramienta crucial para comprender y abordar las desigualdades socioecon√≥micas en el √°mbito urbano. Este √≠ndice proporciona informaci√≥n detallada sobre las condiciones de marginaci√≥n en las colonias de las ciudades, lo que permite identificar las √°reas con mayores necesidades y focalizar los esfuerzos de desarrollo y pol√≠ticas p√∫blicas de manera m√°s efectiva.   

Para el a√±o 2020, se dio a la tarea de estimar por primera vez un √çndice de marginaci√≥n urbana por colonia, como una forma de ofrecer un producto que condensa once formas de exclusi√≥n de los beneficios del desarrollo y que permite observar territorialmente la intensidad de la marginaci√≥n en las colonias de las urbes de M√©xico. Este √≠ndice se construye considerando m√∫ltiples dimensiones, como el acceso a servicios b√°sicos, la vivienda, la educaci√≥n, la salud, y infraestructura.    

Este √≠ndice tiene diversos prop√≥sitos:      

- **Identificaci√≥n de colonias marginadas**: El √≠ndice permite identificar las colonias urbanas con mayores niveles de marginaci√≥n y pobreza. Esto es fundamental para dirigir los recursos y programas hacia las √°reas que requieren una atenci√≥n prioritaria.      

- **Distribuci√≥n de recursos**: El √≠ndice de marginaci√≥n a nivel de colonia ayuda a asignar recursos de manera equitativa, tanto a nivel municipal como estatal y federal. Permite que los fondos p√∫blicos se destinen de manera adecuada a las colonias con mayores necesidades, garantizando una distribuci√≥n m√°s justa de los recursos.    

- **Planificaci√≥n urbana y desarrollo local**: El √≠ndice de marginaci√≥n es utilizado en la planificaci√≥n del desarrollo urbano y local. Ayuda a identificar las √°reas que requieren inversiones en infraestructura, servicios b√°sicos y equipamiento comunitario, fomentando un desarrollo m√°s equilibrado y sostenible.   

- **Evaluaci√≥n de pol√≠ticas p√∫blicas**: El √≠ndice de marginaci√≥n tambi√©n permite evaluar el impacto de las pol√≠ticas y programas implementados para reducir la pobreza y la desigualdad en las colonias urbanas. Ayuda a monitorear el progreso a lo largo del tiempo y realizar ajustes necesarios en las estrategias en curso.    

La importancia del √≠ndice de marginaci√≥n a nivel de colonia urbana en las pol√≠ticas p√∫blicas radica en su capacidad para proporcionar una visi√≥n detallada y precisa de las condiciones de marginaci√≥n en las √°reas urbanas. Permite una toma de decisiones m√°s informada y basada en evidencia, facilitando la asignaci√≥n adecuada de recursos y programas para abordar las desigualdades y promover el desarrollo inclusivo en las colonias m√°s necesitadas. Adem√°s, al monitorear los cambios en el √≠ndice con el tiempo, se puede evaluar el impacto de las pol√≠ticas implementadas y realizar ajustes necesarios para lograr una mayor equidad y bienestar en las √°reas urbanas de M√©xico.     

**Base de datos** de los tres a√±os se encuentran disponibles en la p√°gina oficial de [CONAPO](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372)   

**Datos abiertos de M√©xico** [datos.gob.mx](https://datos.gob.mx/busca/dataset/indice-de-marginacion-carencias-poblacionales-por-localidad-municipio-y-entidad)   

**Publicaci√≥n** [√çndice De Marginaci√≥n Por Entidad Federativa Y Municipio 2020](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372).    

**√çndice de marginaci√≥n a nivel estatal** [Bookdown](https://dvillasanao.github.io/IME_2010_2020/)   
**√çndice de marginaci√≥n a nivel municipal** [Bookdown](https://dvillasanao.github.io/IMM_2010-2020/)   
**√çndice de marginaci√≥n a nivel localidad** [Bookdown](https://dvillasanao.github.io/IML_2010_2020/)   
**√çndice de marginaci√≥n a nivel AGEB** [Bookdown](https://dvillasanao.github.io/IML_2010-2020/)   
**√çndice de marginaci√≥n a nivel Colonia** [Bookdown](https://dvillasanao.github.io/IMC_2020/)     

```{r, include=FALSE}
# automatically create a bib database for R packages
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE, 
                       eval = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(rprojroot::find_rstudio_root_file())
```  

```{r, echo = FALSE, results=FALSE}
#Font Stlye
require(showtext)
library(extrafont)
# activar showtext
windowsFonts()
#Century Gothic
```


```{r, echo = FALSE, results=FALSE}
# Librer√≠as que se usaron en el documento
require(Cairo)
require(ggplot2)
require(ggridges)
require(grDevices)
require(ggpubr)
require(dplyr)
require(p2distance)
require(stratification)
require(knitr)
require(magrittr)
require(kableExtra)
require(openxlsx)
require(tidyverse)
require(readxl)
require(psych)
require(stringr)
require(corrplot)
require(forcats)
require(gt)
require(rgdal)      
require(geojsonio)
require(jsonlite)
require(leaflet)
require(htmlwidgets)
require(leaflet.extras)
require(mapview)
require(leaflet.providers)
```

```{r include=FALSE, eval=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown', 'dp2distance', 'statification', 'corrplot'
), 'packages.bib')
```


```{r, echo = FALSE}
load(file = paste0(here::here(), "/Output/IMC_2020.RData"))

p <- DP2_2020 %>%
      group_by(GM_2020) %>%
       summarise(POB_TOT = sum(POB_TOT),
                 GM = n())

tabla <- p %>%
          janitor::adorn_totals(fill = "-", where = "row")

tabla %>% 
 gt() %>%
  tab_header(title = "Nacional: Poblaci√≥n y unidades geograficas seg√∫n el √≠ndice de marginaci√≥n, 2020") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = 'Century Gothic',
               table.align = "center",
               table.font.size = 10,
               data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
     tab_style(style = list(cell_text(weight = 'bold')),
               locations = cells_body(columns = everything(), rows = tidyselect::last_col())) %>%
      cols_label(`POB_TOT` = md("**Poblaci√≥n 2020**"),
                 `GM` = md("**Colonias**"),
                 `GM_2020` = md("**Grados**")) %>%
       fmt_integer(columns = c(2:3), sep_mark = " ") %>%
        tab_spanner(label = "2020",
                    columns = c(2:3)) %>%
         as_raw_html() 
```

<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Indicadores simples  {.unlisted .unnumbered}


### Porcentaje de poblaci√≥n de 6 a 14 a√±os que no asiste a la escuela $(I_{1}^{i})$ {-}     

El indicador se obtiene dividiendo el monto de poblaci√≥n de 6 a 14 a√±os que no asiste a la escuela entre la diferencia de la poblaci√≥n total de 6 a 14 a√±os y aquellos que no especificaron su condici√≥n de asistencia a la escuela:    

$$I_{1}^{i}=\frac{{PNS}^{i}_{6-14}}{{P}^{i}_{6-14}-{PNEAS}^{i}_{6-14}}\times100$$  

donde:   

$PNS^{i}_{6-14}$: es la poblaci√≥n de 6 a 14 a√±os que no asiste a la escuela,   
$P^{i}_{6-14}$: es la poblaci√≥n total de 6 a 14 a√±os, y   
$PNEAS^{i}_{6-14}$: es la poblaci√≥n de 6 a 14 a√±os que no especific√≥ su condici√≥n de asistencia a la escuela.    

### 	Porcentaje de poblaci√≥n de 15 a√±os o m√°s sin educaci√≥n b√°sica $(I_{2}^{i})$ {-}

El indicador mide la magnitud de la poblaci√≥n sin educaci√≥n b√°sica completa. Su c√°lculo se realiza en dos etapas. En la primera, la poblaci√≥n que no especific√≥ su √∫ltimo grado aprobado en secundaria o en estudios t√©cnicos o comerciales con primaria terminada, se distribuye entre la poblaci√≥n que aprob√≥ entre uno y dos grados en estos mismos niveles educativos, aplicando la siguiente f√≥rmula:   

$${PSI}_{15+}^{i}={PSCI}_{15+}^i+\left[\frac{{PSCI}_{15+}^i}{{PSCI}_{15+}^i+{PSCC}_{15+}^i}\times{PNEGS}_{15+}^i\right]$$


donde:    

$P{SI}_{15+}^{i}$: es la poblaci√≥n de 15 a√±os o m√°s que aprob√≥ entre el primer y segundo grado de secundaria o estudios t√©cnicos o comerciales con primaria terminada con los no especificados de estos niveles educativos ya distribuidos,  
${PSCI}_{15+}^{i}$: es la poblaci√≥n de 15 a√±os o m√°s que declar√≥ haber aprobado entre el primer y segundo grado de secundaria o estudios t√©cnicos o comerciales con primaria terminada,  
${PSCC}_{15+}^{i}$: es la poblaci√≥n de 15 a√±os o m√°s que curs√≥ el tercer grado en secundaria o tres o cuatro grados en estudios t√©cnicos o comerciales con primaria terminada, y  
${PNEGS}_{15+}^{i}$: es la poblaci√≥n de 15 a√±os o m√°s que no especific√≥ su √∫ltimo grado cursado en secundaria o en estudios t√©cnicos o comerciales con primaria terminada.  

Con el dato de la poblaci√≥n con estudios truncos en secundaria o en estudios t√©cnicos o comerciales con primaria terminada, se procedi√≥ a calcular el indicador de porcentaje de poblaci√≥n sin educaci√≥n b√°sica. Este porcentaje se calcula dividiendo la poblaci√≥n de 15 a√±os o m√°s sin educaci√≥n b√°sica, entre la diferencia de la poblaci√≥n total de 15 a√±os o m√°s y aquellos que no especificaron su nivel educativo:   

$$I_{2}^{i}=\frac{{PSIN}_{15+}^i+{PPI}_{15+}^i+{PSI}_{15+}^i}{P_{15+}^i-{PNEIN}_{15+}^i}\times100$$

donde:

${PSIN}_{15+}^{i}$: es la poblaci√≥n de 15 a√±os o m√°s sin instrucci√≥n,  
${PPI}_{15+}^{i}$: es la poblaci√≥n de 15 a√±os o m√°s con alg√∫n grado en educaci√≥n primaria,  
${PSI}_{15+}^{i}$: es la poblaci√≥n de 15 a√±os o m√°s con nivel incompleto de secundaria o estudios t√©cnicos o comerciales con primaria terminada,   
$P_{15+}^{i}$: es la poblaci√≥n total de 15 a√±os o m√°s, y   
${PNEIN}_{15+}^{i}$: es la poblaci√≥n de 15 a√±os o m√°s que no especific√≥ su nivel de instrucci√≥n.   


### Porcentaje de poblaci√≥n sin derechohabiencia a los servicios de salud $(I_{3}^{i})$ {-}    

En este indicador se identifica a la poblaci√≥n sin derechohabiencia a los servicios de salud y se divide entre el total de poblaci√≥n menos el n√∫mero de personas que no especific√≥ su condici√≥n de derechohabiencia a los servicios de salud:  

$$I_{3}^{i}=\frac{{PSD}^{i}}{{P}^{i}-{PNESD}^{i}}\times100$$  

donde:    
${PSD}^{i}$: es la poblaci√≥n sin derechohabiencia a los servicios de salud,     
${P}^{i}$: es la poblaci√≥n total, y    
${PNESD}^{i}$: es la poblaci√≥n que no especific√≥ su condici√≥n de derechohabiencia a los servicios de salud.    

### Porcentaje de ocupantes en viviendas particulares sin drenaje ni sanitario $(I_{4}^{i})$ {-} 

Este porcentaje se obtiene al dividir el n√∫mero de ocupantes de viviendas particulares sin drenaje ni sanitario, entre el n√∫mero de ocupantes en viviendas particulares, menos el n√∫mero de ocupantes de viviendas particulares en donde no se especific√≥ la disponibilidad de drenaje ni sanitario:  

$$I_{4}^{i}=\frac{{OVSDS}^{i}}{{OVP}^{i}-{ONEDS}^{i}}\times100$$


donde:

${OVSDS}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de drenaje ni sanitario,   
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEDS}^{i}$: son los ocupantes de viviendas particulares en donde no se especific√≥ la disponibilidad de drenaje ni sanitario.    

### Porcentaje de ocupantes en viviendas particulares sin energ√≠a el√©ctrica $(I_{5}^{i})$ {-}

Este indicador se obtiene al dividir el n√∫mero de ocupantes de viviendas particulares sin disponibilidad de energ√≠a el√©ctrica, entre el n√∫mero de ocupantes en viviendas particulares menos el n√∫mero de ocupantes de viviendas particulares en donde no se especific√≥ la existencia de luz el√©ctrica:   

$$I_{5}^{i}=\frac{{OSEE}^i}{{OVP}^{i}-{ONEEE}^{i}}\times100$$  
donde:   

${OVSDS}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de drenaje ni sanitario,  
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEDS}^{i}$: son los ocupantes de viviendas particulares en donde no se especific√≥ la disponibilidad de drenaje ni sanitario.   


### Porcentaje de ocupantes en viviendas particulares sin agua entubada $(I_{6}^{i})$ {-}     
	
Para obtener este indicador se divide el n√∫mero de ocupantes en viviendas particulares que no disponen de agua entubada, entre la diferencia del total de ocupantes en viviendas particulares y el total de ocupantes en viviendas en donde no se especific√≥ la disponibilidad de agua entubada:   

$$I_{6}^{i}=\frac{{OSAE}^i}{{OVP}^i-{ONEAE}^i}\times100$$   

donde:  

${OSAE}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de agua entubada,  
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEAE}^{i}$: son los ocupantes de viviendas particulares en donde no se especific√≥ la disponibilidad de agua entubada.   


### Porcentaje de ocupantes en viviendas particulares con piso de tierra $(I_{7}^{i})$ {-}  

En este indicador se identifican los ocupantes de viviendas particulares con piso de tierra y se divide entre el total de ocupantes en viviendas particulares, menos el n√∫mero de ocupantes de viviendas particulares en donde no se especific√≥ el material predominante en pisos:    

$$I_{7}^{i}=\frac{{OPT}^i}{{OVP}^i-{ONEMP}^i}\times100$$    

donde:   

${OPT}^{i}$: son los ocupantes de viviendas particulares con piso de tierra,    
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEMP}^{i}$: son los ocupantes de viviendas particulares en las que no se especific√≥ el material predominante en pisos.    

### Porcentaje de ocupantes en viviendas particulares con hacinamiento $(I_{8}^{i})$ {-}  

El procedimiento para el c√°lculo de este indicador const√≥ de dos etapas. Primero, en cada vivienda particular habitada se dividi√≥ el n√∫mero de ocupantes entre el n√∫mero de cuartos dormitorio, para identificar las viviendas con hacinamiento:    

$$OVHAC=\frac{OVP}{CDVP}$$   
donde:

$VHAC$: es la vivienda con hacinamiento,   
$OVP$: es el n√∫mero de ocupantes que residen habitualmente una vivienda particular, y    
$CDVP$: es el n√∫mero de cuartos dormitorio en una vivienda particular.   
	
En la segunda fase de c√°lculo, se dividi√≥ el n√∫mero de ocupantes en viviendas particulares con hacinamiento, entre el total de ocupantes en viviendas particulares habitadas menos el n√∫mero de ocupantes en viviendas particulares habitadas donde no se especific√≥ el n√∫mero de cuartos dormitorio:     

$$I_{8}^{i}=\frac{O{VHAC}^i}{{OVP}^i-{ONECD}^i}\times100$$    

donde:

${OVHAC}^{i}$: son los ocupantes en viviendas particulares con hacinamiento,   
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONECD}^{i}$: son los ocupantes en viviendas particulares en donde no se especific√≥ el n√∫mero de cuartos dormitorio.     

### Porcentaje de ocupantes en viviendas particulares sin refrigerador $(I_{9}^{i})$ {-}   
	
En este indicador se identifican los ocupantes en viviendas particulares que no disponen de refrigerador y se divide entre el total de ocupantes en viviendas particulares menos los ocupantes en viviendas particulares que no especificaron la disponibilidad de refrigerador:    

$$I_{9}^{i}=\frac{{OSR}^i}{{OVP}^i-{ONER}^i}\times100$$  

donde:   

${OSR}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de refrigerador,     
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y    
${ONER}^{i}$: son los ocupantes de viviendas particulares en donde no se especific√≥ la disponibilidad de refrigerador.   

###  Porcentaje de ocupantes en viviendas particulares sin internet $(I_{10}^{i})$ {-}    

El indicador se calcul√≥ dividiendo el n√∫mero de ocupantes en viviendas particulares que no disponen de servicio de internet, entre el total de ocupantes en viviendas particulares menos los ocupantes en viviendas particulares donde no se especific√≥ la disponibilidad de internet:   

$$I_{10}^{i}=\frac{{OSI}^i}{{OVP}^i-{ONEI}^i}\times100$$  
donde:
${OSI}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de internet,   
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEI}^{i}$: son los ocupantes de viviendas particulares en las que no se especific√≥ la disponibilidad de internet.     


### Porcentaje de ocupantes en viviendas particulares sin celular $(I_{11}^{i})$ {-}    

Este indicador se obtiene dividiendo el n√∫mero de ocupantes en viviendas particulares que no disponen de celular, entre el total de ocupantes en viviendas particulares menos los ocupantes en viviendas particulares que no especificaron la disponibilidad de celular:   

$$I_{11}^{i}=\frac{{OSC}^i}{{OVP}^i-{ONEC}^i}\times100$$  
donde:
${OSC}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de celular,    
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEC}^{i}$: son los ocupantes de viviendas particulares en las que no se especific√≥ la disponibilidad de celular.    

**Indicadores simples**  

```{r}
Indicadores <- c(
                 'Porcentaje de poblaci√≥n de 6 a 14 a√±os que no asiste a la escuela', 
                 'Porcentaje de poblaci√≥n de 15 a√±os y m√°s sin educaci√≥n b√°sica',
                 'Porcentaje de poblaci√≥n sin derechohabiencia a los servicios de salud',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas sin drenaje ni excusado',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas sin energ√≠a el√©ctrica',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas sin agua entubada',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas con piso de tierra',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas con alg√∫n nivel de hacinamiento',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas sin refrigerador',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas sin internet',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas sin celular'
                 )
```
	




	

	
	
 




<!--chapter:end:01-Indicadores.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Base de datos {.unlisted .unnumbered}

El √çndice de marginaci√≥n urbana por colonia 2020 se desarroll√≥ con informaci√≥n socioecon√≥mica a nivel de AGEB urbana proveniente del Censo de Poblaci√≥n y Vivienda 2020 mediante una petici√≥n de informaci√≥n al Laboratorio de Microdatos del INEGI (2010 y 2021a). Esta solicitud sirvi√≥ para la estimaci√≥n de los √≠ndices de marginaci√≥n de 50 790 AGEB urbanas. Con los datos absolutos de estas AGEB urbanas se estimaron los indicadores socioecon√≥micos a nivel de colonias. 

**A continuaci√≥n, se carga la base de datos correspondiente al √≠ndice de marginaci√≥n por colonia (2020).** 

```{r}
load(file = paste0(here::here(), "/Bases/IMC_2020.RData")) 
```

<div style="height:700px;overflow:auto;">
```{r, echo = FALSE}
require(gt)
tabla_2020 %>% 
 rename("A√ëO" = "ANIO") %>%
  slice(1:20) %>%
    gt() %>%
     tab_header(title = "Indicadores simples de marginaci√≥n",
                 subtitle = "2020") %>%
      fmt_number(columns = names(tabla_2020)[13:23], 
                  decimals = 2) %>%
       fmt_integer(columns = "POB_TOT", 
                    sep_mark = " ") %>%
        tab_options(heading.title.font.size = 14, 
                    heading.subtitle.font.size = 12,
                    table.font.names = 'Century Gothic',
                    table.font.size = 10,
                    data_row.padding = px(1)) %>%
         tab_style(style = list(cell_text(align = "left",
                                           weight = 'bold')),
                    locations = list(cells_title(groups = c("title")))) %>%
          tab_style(style = list(cell_text(align = "left")),
                     locations = list(cells_title(groups = c("subtitle")))) %>%
           cols_label(CVE_COL = md("**CVE_COL**"),
                      ID_COL = md("**ID_COL**"),
                      ID_INE_2020 = md("**ID_INE_2020**"),
                      NOM_COLONIA = md("**NOM_COLONIA**"),
                      CP = md("**CP**"),
                      CLASIF = md("**CLASIF**"),
                      CVE_ENT = md("**CVE_ENT**"),
                      NOM_ENT = md("**NOM_ENT**"), 
                      CVE_MUN = md("**CVE_MUN**"), 
                      NOM_MUN = md("**NOM_MUN**"),
                      POB_TOT = md("**POB_TOT**"), 
                      A√ëO = md("**A√ëO**"), 
                      P6A14NAE = md("**P6A14NAE**"),
                      SBASC = md("**SBASC**"),
                      PSDSS = md("**PSDSS**"),
                      OVSDE = md("**OVSDE**"),
                      OVSEE = md("**OVSEE**"),
                      OVSAE = md("**OVSAE**"),
                      OVPT= md("**OVPT**"),
                      OVHAC = md("**OVHAC**"),
                      OVSREF = md("**OVSREF**"),
                      OVSINT = md("**OVSINT**"),
                      OVSCEL = md("**OVSCEL**")) %>%
         cols_width(starts_with("POB") ~ px(80), 
                    starts_with("NOM") ~ px(180), 
                    starts_with("NOM_C") ~ px(360), 
                    everything() ~ px(60)) %>%
            as_raw_html() 
```
</div>

<!--chapter:end:02-Datos.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# An√°lisis de correlaciones  {.unlisted .unnumbered}

La funci√≥n `corrplot` en `R` es utilizada para crear matrices de correlaci√≥n visualmente atractivas y f√°ciles de interpretar. Esta funci√≥n es parte del paquete `corrplot`, que proporciona herramientas para visualizar y analizar matrices de correlaci√≥n.   

La matriz de correlaci√≥n es una tabla que muestra las correlaciones entre pares de variables. En an√°lisis de datos, la correlaci√≥n se utiliza para medir la relaci√≥n entre dos variables. Puede ser √∫til para comprender c√≥mo se relacionan diferentes variables entre s√≠ y c√≥mo afectan a otras variables en un conjunto de datos.   
 
```{r, fig.align='center', fig.width=12, fig.height=12, out.width='100%', eval = FALSE}
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7", "#FFFFFF", "#D1E5F0", "#92C5DE","#4393C3", "#2166AC", "#053061"))
par(mfrow = c(1,1), family = "Century Gothic", mar = c(0.5, 0, 0, 0), cex.main = 3, col.main = "#053061")
#An√°lisis de correlaciones
corrplot(cor(tabla_2020[,13:23]) ,
          title = "2020",
           type = "upper",
            method = "color",
             col = col2(100),
              tl.col = "blue4",
               tl.offset = 0.1,
                tl.cex = 2.7,
                 tl.srt = 90,
                  cl.align.text = "c",
                   number.cex = 1.9,
                    cl.cex = 2.1,
                     addCoef.col = "white", # Add coefficient of correlatio
                      mar = c(10, 0, 2.5,0))
```

<a href="https://raw.githubusercontent.com/dvillasanao/IMC_2020/main/img/correlaciones_2020.png" data-lightbox="image-1" data-title="correlaciones">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/img/correlaciones_2020.png"))
```
</a>





<!--chapter:end:03-Correlaciones.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# M√©todo de Distancias $DP2$  {.unlisted .unnumbered}


Jos√© Bernardo Pena Trapero: `Problemas de la medici√≥n del bienestar y conceptos afines (1977)` 

Los m√©todos de distancias son enfoques utilizados para medir el bienestar o la calidad de vida de las personas a trav√©s de la comparaci√≥n de diferentes dimensiones o indicadores. Estos m√©todos se basan en la idea de que el bienestar se puede evaluar considerando la distancia o diferencia entre los individuos en t√©rminos de ciertos atributos o variables relevantes.   
La Distancia $DP_{2}$, es un indicador sint√©tico, definido por el profesor `J. Bernardo Pena Trapero`, basado en el concepto de distancia, construido, como su nombre indica para medir distancias entre unidades geogr√°ficas, o bien, tambi√©n se puede aplicar a comparaciones tanto cronol√≥gicas como interespaciales.     
   

**Definici√≥n**

Sean:   

$\:\:\circ\:r$, el n√∫mero de municipios;  
$\:\:\circ\:n$, el n√∫mero de variables;  
$\:\:\circ\:x_{ij}$, el valor de la variable j en la AGEB $i$;  
$\:\:\circ\:\sigma_{j}$, La Desviaci√≥n T√≠pica de la variable $j$;   
$\:\:\circ\:R^{2}_{i,i-1,...,1}$ el Coeficiente de Determinaci√≥n en la Regresi√≥n de $X_{i}$ sobre $X_{i-1},X_{i-2},...,X_{1}$. 

Se define la $Distancia-P_{2}$ de la forma:    

\begin{align}
DP_{2}=\sum^{n}_{i=1}\frac{d_{i}}{\sigma_{i}}(1-R^{2}_{i,i-1,...,1})\:\:;\;\;con \:\:R^{2}_{1}=0
\end{align}

Donde:     

$\:\:\circ\:d_{i} = d_{i}(r,*) = |x_{ri}-x_{*i}|$ |: es la distancia de la j-√©sima variable del municipio $r$ con respecto a la base de referencia $x_{*}=(x_{*1}, x_{*2},..., x_{*n})$. Tomando como punto de referencia el valor m√≠nimo de la variable, siendo esta la peor situaci√≥n te√≥rica,      

 $\:\:\circ\:\sigma_{i}$ : es la desviaci√≥n est√°ndar de la variable $ùëó$,     
 
 $\:\:\circ\:R^{2}_{i,i-1,...,1}$: es el coeficiente de determinaci√≥n de la regresi√≥n del indicador parcial $ùëó$ con respecto a los otros indicadores $(ùëó‚àí1,ùëó‚àí2,‚Ä¶,1)$. Esta expresi√≥n es parte de la varianza del indicador parcial $I_{j}$ que se explica linealmente por el resto de los indicadores parciales,        

$\:\:\circ\:(1-R^{2}_{i,i-1,...,1})$): es el factor corrector que evita la duplicidad, al eliminar la informaci√≥n parcial de los indicadores ya contenidos en los indicadores precedentes, y     

$\:\:\circ\:R^{2}_{1}=0$; porque la primera componente aporta toda la informaci√≥n y al no existir un componente previo su ponderaci√≥n es la unidad.  

El $DP_{2}$ cumple con las siguientes propiedades: no negatividad, homogeneidad, conmutatividad, desigualdad triangular, existencia y determinaci√≥n, monoton√≠a, unicidad, transitividad, no duplicidad de informaci√≥n, invariancia al cambio de origen y/o de escala en las unidades y exhaustividad.      


El orden de entrada de las variables   

```{r}
# Se multiplica por -1, debido a que son indicadores de carencia 
assign("DP2_datos_2020", -1 * tabla_2020[13:23])  
```

Para asegurar las propiedades del indicador sint√©tico, un aumento en los indicadores simples implica un aumento en la carencia de los servicios, lo que implicar√≠a una disminuci√≥n de la calidad de vida, por lo que se multiplica cada indicador por **-1**, de esta forma, un aumento en la variable supone una mejora en la calidad de vida.    


## Base de referencia  {-}

Se define al valor de referencia para cada uno de los indicadores parciales, con la finalidad de hacer comparaciones entre las diferentes unidades espaciales (Colonias). Siendo este el valor m√≠nimo de cada indicador simple como referencia, representado como la ‚Äúsituaci√≥n no deseada‚Äù. Como resultado, un valor alto implicar√≠a una distancia alejada con respecto a una situaci√≥n te√≥rica ‚Äúsituaci√≥n no deseada‚Äù. Por lo tanto $d_{ij}$ mide la distancia entre el indicador parcial $j$ en la entidad $i$ y su valor de referencia.    

Se toma como base de referencia el valor del m√≠nimo del a√±o `2020`, ya que este tipo de cambio permitir√° la comparabilidad en el tiempo.    

```{r}
#Base de referencia 2010 - 2020
minRV_2020 <- makeReferenceVector(X = DP2_datos_2020, 
                                   reference_vector_function = min)
```


```{r, echo = FALSE}
minRV <- minRV_2020 %>%
          as.data.frame() %>%
           tibble::rownames_to_column(.data = .) %>%
            dplyr::mutate(rowname = case_when(rowname %in% 1 ~ "2020")) %>%
             rename("ANIO" = "rowname")

minRV %>% 
  rename("A√ëO" = "ANIO") %>%
   gt() %>%
    tab_header(title = "Base de referencia") %>%
     fmt_number(columns = names(tabla_2020)[13:23], 
                decimals = 2) %>%
      tab_options(heading.title.font.size = 14, 
                  heading.align = "center",
                  heading.subtitle.font.size = 12,
                  table.align = "center",
                  table.font.names = 'Century Gothic',
                  table.font.size = 10) %>%
       tab_style(style = list(cell_text(align = "center",
                                         weight = 'bold')),
                  locations = list(cells_title(groups = c("title")))) %>%
        tab_style(style = list(cell_text(align = "left")),
                   locations = list(cells_title(groups = c("subtitle")))) %>%
         cols_label(A√ëO = md("**A√ëO**"), 
                    P6A14NAE = md("**P6A14NAE**"),
                    SBASC = md("**SBASC**"),
                    PSDSS = md("**PSDSS**"),
                    OVSDE = md("**OVSDE**"),
                    OVSEE = md("**OVSEE**"),
                    OVSAE = md("**OVSAE**"),
                    OVPT= md("**OVPT**"),
                    OVHAC = md("**OVHAC**"),
                    OVSREF = md("**OVSREF**"),
                    OVSINT = md("**OVSINT**"),
                    OVSCEL = md("**OVSCEL**")) %>%
          as_raw_html() 
```



## M√©todo de Distancia $DP_{2}$  {-}   

```{r, results=FALSE}
require(p2distance)
##Calculo del M√©todo de Distancias DP2
ind_2020 <- p2distance(matriz = as.matrix(DP2_datos_2020), 
                        reference_vector = minRV_2020, 
                         iterations = 50)
```

**Total de iteraciones**

```{r, collapse=TRUE}
iteration <- ind_2020[["iteration"]]
```


```{r, echo=FALSE}
tabla <- iteration %>%
          as.data.frame() %>%
           tibble::rownames_to_column(.data = .) %>%
            dplyr::mutate(rowname = case_when(rowname %in% 1 ~ "2020")) %>%
              rename("ANIO" = "rowname",
                     "iteraciones" = ".")

tabla %>% 
 rename("A√ëO" = "ANIO") %>%
  gt() %>%
   tab_header(title = "N√∫mero de iteraciones") %>%
    fmt_integer(columns = "iteraciones") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = 'Century Gothic',
                 table.align = "center",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                        weight = 'bold')),
                 locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                  locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_label(A√ëO = md("**A√ëO**"), 
                   iteraciones = md("**Iteraciones**")) %>%
         as_raw_html() 
```




Se anexan los resultados a las bases de datos original

```{r}
DP2_2020 <- cbind(tabla_2020, ind_2020[["p2distance"]])
names(DP2_2020) <- c(names(DP2_2020)[1:23], paste0("IM_2020"))
```

<!--chapter:end:04-Distancias.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# M√©todo de estratificaci√≥n  {.unlisted .unnumbered}

### Identificaci√≥n de datos at√≠picos {-}   

Para hacer cumplir la definici√≥n de los l√≠mites en el m√©todo de estratificaci√≥n [v√©ase: `M√©todo de estratificaci√≥n de Dalenius & Hodges`] y el n√∫mero √≥ptimo de clases basados en la media aritm√©tica, es importante la identificaci√≥n de datos at√≠picos porque podr√≠an ocasionar resultados poco adecuados. Para contrarrestar este problema, `Hubert y Vandervieren (2007)` proponen el m√©todo de caja, el cual toma en cuenta el grado de asimetr√≠a de un conjunto de datos.  

$$\left[Q_{1} - 1.5e^{-4MC} IQR; \hspace{0.5cm}  Q_{3} + 1.5e^{-4MC} IQR \right] \text{para } MC \geq 0$$
$$\left[Q_{1} - 1.5e^{-3MC} IQR; \hspace{0.5cm}  Q_{3} + 1.5e^{-3MC} IQR \right] \text{para } MC < 0$$
donde:   
$\circ \:ùëÑ_{1}$ ùë¶ $ùëÑ_{3}$: hacen referencia al primer y tercer cuartil, respectivamente; la diferencia entre estos dos valores da como resultado el valor de espacio intercuartil ($ùêºùëÑùëÖ$), y    
$\circ \:ùëÄùê∂ (ùëöùëíùëëùëêùëúùë¢ùëùùëôùëí)$: cuantifica el grado de asimetr√≠a de una muestra univariable ${ùë•_1,ùë•_2,‚Ä¶ ,ùë•_ùëõ}$.     

Se identifican los valores at√≠picos para cada conjunto de datos. 

- Se calculan los estad√≠sticos de la columna del √≠ndice de marginaci√≥n para cada conjunto de datos $DP2_{i}$ correspondientes al a√±o y se asigna el resultado a una nueva variable denominada $outliers_i$.    

```{r}
assign(paste0("outliers_2020"), boxplot.stats(DP2_2020[,24]))
```

Se crea un data.frame que contiene el n√∫mero de valores at√≠picos, su rango y el l√≠mite inferior para cada conjunto de datos.

```{r, echo = FALSE}
#L√≠mites para el c√°lculo de estratificaci√≥n a nivel localidad, 2020
p <- data.frame(n = length(outliers_2020$out), 
                rango = range(outliers_2020$out), 
                lim = outliers_2020$stats[1])
```

```{r, echo = FALSE}
tabla <- data.frame(outliers = p$n[1],
                    minimo = p$rango[1],
                    maximo = p$rango[2])   
tabla %>% 
 gt() %>%
   tab_header(title = "L√≠mites para el c√°lculo de estratificaci√≥n a nivel colonia, 2020") %>%
    fmt_number(columns = c(2:3), decimals = 3) %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = 'Century Gothic',
                table.align = "center",
                table.font.size = 10,
                data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
                locations = list(cells_title(groups = c("subtitle")))) %>%  
      cols_label(outliers = md("**Valores at√≠picos**"), 
                minimo = md("**M√≠nimo**"),
                maximo = md("**L√≠mite**")) %>%
       tab_spanner(label = "Rango",
                   columns = c(minimo, maximo)) %>%
         as_raw_html() 

```

Se identifican los casos extremos en el √≠ndice de marginaci√≥n y se aplica el m√©todo de caja propuesto por `Hubert y Vandervieren`, concluyendo los l√≠mites con los que se debe trabajar.      

Se a√±ade una nueva columna `IM_out`. Esta columna se calcula usando `if_else`, de la siguiente manera:   

- Si el valor de IM es mayor o igual al l√≠mite inferior de los valores no considerados outliers `(get(paste0("outliers_", i))$stats[1])`, entonces `IM_out` toma el valor de `IM`.   
- Si el valor de IM es menor que el l√≠mite inferior, entonces `IM_out` toma el valor del l√≠mite inferior, eliminando as√≠ los outliers.      


```{r}
## Se crea un √≠ndice ficticio, en la que se quitan los outliers   
DP2_2020 <- DP2_2020 %>%
             mutate(IM_out = ifelse(get(paste(colnames(DP2_2020))[24]) >= outliers_2020$stats[1],
                                    get(paste(colnames(DP2_2020))[24]),
                                    outliers_2020$stats[1]))
```


### M√©todo de estratificaci√≥n de Dalenius & Hodges {-}

`strata.cumrootf`: cumulative root frequency method by Dalenius and Hodges (1959). 

Con la obtenci√≥n del √≠ndice de marginaci√≥n a trav√©s del m√©todo DP2, los valores se clasificaron en cinco categor√≠as ordinales con el m√©todo de Dalenius y Hodges (1959), para obtener el grado de marginaci√≥n. Este m√©todo forma estratos de manera que la varianza sea m√≠nima al interior de cada estrato y m√°xima entre cada uno de ellos, es decir, son lo m√°s homog√©neos posibles. Este procedimiento utiliza la ra√≠z de las frecuencias acumuladas para la construcci√≥n de los estratos, por lo que se lleva a cabo para la divisi√≥n de la poblaci√≥n en el estrato L. Esta es una soluci√≥n aproximada de Dalenius y Hodges (1959) a las ecuaciones de Dalenius (1950). De acuerdo con Gunning y Horgan (2004), el l√≠mite superior de cada estrato se determin√≥ con la siguiente expresi√≥n:  

$$Q = \frac{1}{L}\sum^{J}_{i=1}{\sqrt{f_{i}}}$$

Sea un conjunto de estratos determinados por su l√≠mite superior,

 $$Q,\ 2Q,\ \ldots,\ \left(L-1\right)Q,\ (L)Q.$$
donde:  

$\circ \:J$: es el n√∫mero de clases dentro del grupo de la variable ordenada X,    
$\circ \:f_{i}\ \in(1,\ \ldots, J)$: es la frecuencia en cada clase  $J$, y  
$\circ \:L$: es el n√∫mero de estratos.   


La eficiencia del m√©todo de la ra√≠z de las frecuencias acumuladas depende principalmente del n√∫mero de clases dentro del grupo de la variable ordenada. Sin embargo, no hay un procedimiento est√°ndar sobre c√≥mo elegir el mejor valor para el n√∫mero de clases, siendo esto una limitante del m√©todo de Dalenius y Hodges. Para medir el efecto del n√∫mero  de clases en la varianza de cada estrato se recurri√≥ a un m√©todo iterativo para obtener un criterio de agrupaci√≥n √≥ptimo.    

Para establecer los l√≠mites de los estratos $(b_{1},\ \ldots,\ b_{L})$ que minimicen la varianza del estimador, se utiliza la asignaci√≥n de Neyman para determinar el tama√±o de muestra √≥ptimo. Sea la varianza del estimador:    

$$V\left({\bar{x}}_{st}\right)=\ \sum_{h}\left(\frac{N_h}{N}\right)^2\frac{S_h^2}{n_h}\ $$
donde:

$\circ  \: S_{h}^{2}$: es la varianza poblacional en el estrato $h$,   
$\circ  \:n_{h}$: es el tama√±o de muestra en el estrato $h$ utilizada por la asignaci√≥n de Neyman, y 
$\circ  \:N_{h}$: es el total de elementos en el estrato $h$, sea $N=\sum_{h=1}^{L}{N_{h}}$.     

Si se asume que la distribuci√≥n dentro de cada estrato se distribuye aproximadamente de manera uniforme, los l√≠mites se obtienen tomando intervalos iguales en la funci√≥n de la ra√≠z de las frecuencias acumuladas. Los l√≠mites se resuelven de manera iterativa:   

$$\frac{S_h^2+(b_h-{\bar{X}}_h)2}{S_h}=\frac{S_{h+1}^2+(b_h-{\bar{X}}_{h+1})2}{S_{h+1}}\ para\ h=1,\ \ldots.\ ,\ L-1$$
donde:

$\circ  \: b_{h}$: es el l√≠mite superior en el estrato $h$,   
$\circ  \: {\bar{X}}_{h}$: es la media poblacional en el estrato $h$, y   
$\circ  \: S_{h}^{2}$: es la varianza poblacional en el estrato $h$.      

El requisito de precisi√≥n, generalmente se establece cuando el coeficiente de variaci√≥n sea igual a un nivel especificado entre 1 y 10 por ciento (Hidiroglou y Kozak, 2018).     

## N√∫mero √≥ptimo de clases del m√©todo de Dalenius & Hodge {-}  

`alloc` lista que especifica el esquema de asignaci√≥n. La lista debe contener 3 n√∫meros para los 3 exponentes q1, q2 y q3 en el esquema de asignaci√≥n general (ver paquete de `stratification`). El valor predeterminado es la asignaci√≥n de **Neyman** (q1 = q3 = 0.5 y q2 = 0)   

A continuaci√≥n, se realiza un an√°lisis de estratificaci√≥n sobre los diferentes a√±os, usando la funci√≥n `strata.cumrootf()`, almacenando los resultados de errores est√°ndar, medias y varianzas en matrices que luego se guardan en listas.   

```{r, results=FALSE, warning=FALSE, eval = FALSE}
iteraciones <- 1000
start.time <- Sys.time()
i <- 1
sd <- matrix(NA, nrow = (iteraciones), ncol = 3)
meanh <- matrix(NA, nrow = (iteraciones), ncol = 6)
varh <- matrix(NA, nrow = (iteraciones), ncol = 6)
for (n in seq(5, iteraciones, 1)){
     cum <- strata.cumrootf(x = DP2_2020[,25], CV = 0.05 , Ls = 5, alloc = c(0.5, 0, 0.5), nclass = n)
     sd[i,] <-  c(n, cum$stderr, cum$CV)
     meanh[i,] <- c(n, cum$meanh)
     varh[i,] <-  c(n, cum$varh)
     i <- i + 1
  }
colnames(sd) <- c("n", "sderr", "CV")
colnames(meanh) <- c("nclass", paste0(rep("Strata", 5), 1:5))
colnames(varh) <- c("nclass", paste0(rep("Strata", 5), 1:5))
end.time <- Sys.time()
time.taken <- round(end.time - start.time, 2)
time.taken
```

```{r, echo = FALSE}
#saveRDS(sd, file = paste0(here::here(), "/Output/sd.RDS"))
sd <- readRDS(file = paste0(here::here(), "/Output/sd.RDS"))
```

#### N√∫mero √≥ptimo de clases {-}

Se toma cada matriz resultante de errores est√°ndar de la lista `stderr`, y luego selecciona la fila que tiene el coeficiente de variaci√≥n (`CV`) m√°s bajo. Estos resultados se almacenan en la lista `min.strata`, la cual contendr√° los data.frames correspondientes a las filas con el menor `CV `para cada uno de los tres conjuntos de datos en `stderr`.  

```{r}
min.strata <- sd %>%
               as.data.frame() %>% 
                slice(which.min(.$CV)) 
```

```{r, echo = FALSE}
tabla <- min.strata %>%
          dplyr::mutate(ANIO = "2020") %>%
           relocate(ANIO, .before = "n")

tabla %>% 
 rename("A√ëO" = "ANIO") %>%
  gt() %>%
   tab_header(title = "N√∫mero √≥ptimo de clases") %>%
    fmt_integer(columns = names(tabla)[2]) %>%
     fmt_number(columns = names(tabla)[3:4],
                decimals = 2) %>%
       tab_options(heading.title.font.size = 14, 
                   heading.subtitle.font.size = 12,
                   table.font.names = 'Century Gothic',
                   table.align = "center",
                   table.font.size = 10) %>%
        tab_style(style = list(cell_text(align = "left",
                                          weight = 'bold')),
                   locations = list(cells_title(groups = c("title")))) %>%
         tab_style(style = list(cell_text(align = "left")),
                    locations = list(cells_title(groups = c("subtitle")))) %>%
          cols_label(A√ëO = md("**A√ëO**"),
                     n = md("**n**"),
                     sderr = md("**sd**"),
                     CV = md("**C.V.**")) %>%
           as_raw_html() 
```



```{r, echo = FALSE, results=FALSE, out.width='80%'}
p <- sd %>%
      as.data.frame() %>% 
       na.omit() %>%
        arrange(desc(.$CV)) %>%
         ggplot() + 
          geom_point(aes(x = seq(1, nrow(sd %>% na.omit())), y = CV)) + 
           geom_line(aes(x = seq(1, nrow(sd %>% na.omit())), y = CV)) +
            geom_hline(data = min.strata, aes (yintercept = CV), color = "red") +
             geom_text(data = min.strata, aes(label = paste0("CV = ", round(CV, 4)), x = iteraciones - 75, y = CV),  
                       vjust = -1,
                        size = 6,
                         color = "red",
                          family = "Century Gothic") +
             geom_hline(data = min.strata, aes(yintercept = CV), color = "red") +
              theme_minimal() + 
               theme(title = element_text(family = "Century Gothic"), 
                      plot.title = element_text(size = 22, family = "Century Gothic"),
                          plot.subtitle = element_text(size = 20, family = "Century Gothic"),
                          axis.text = element_text(size = 14, family = "Century Gothic"),
                          axis.title = element_text(size = 18, family = "Century Gothic")) + 
                     scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
                 labs(title = "Coeficiente de variaci√≥n √≥ptimo",
                       subtitle = '2020',
                        y = "CV", 
                         x = "iteraciones") 
```


<a href="https://raw.githubusercontent.com/dvillasanao/IMC_2020/main/img/iteraciones.png" data-lightbox="image-1" data-title="iteraciones">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
knitr::include_graphics(paste0(here::here(), "/img/iteraciones.png"))
```
</a>

Se toman en cuenta el n√∫mero de clases que salen del los resultados del m√©todo iterativo. Utilizando la funci√≥n `strata.cumrootf()` de la paqueter√≠a `stratification` con par√°metros espec√≠ficos y el n√∫mero de clases (`nclass`) obtenido de `min.strata`.       
- `CV = 0.05`: Establece el coeficiente de variaci√≥n.   
- `Ls = 5`: Establece el n√∫mero de estratos.   
- `alloc = c(0.5, 0, 0.5)`: Define la asignaci√≥n para la estratificaci√≥n.    
- `nclass = min.strata[,1]`: Establece el n√∫mero de clases utilizando el primer valor de la fila con el menor CV en `min.strata`.  

```{r}
strata.DP2 <- strata.cumrootf(DP2_2020[,25], 
                               CV = 0.01, 
                                Ls = 5, 
                                 alloc = c(0.5, 0, 0.5), 
                                  nclass = min.strata[,1])
```

Se agregan los datos a la base original

```{r}
##Se agrega a la base DP2
DP2_2020 <- data.frame(DP2_2020 %>% 
                        select(-IM_out), ## Se elimina el √≠ndice ficticio
                         strata.DP2[["stratumID"]])

# Se cambian los nombres de las columnas 
names(DP2_2020) <- c(names(DP2_2020)[1:23],
                      paste0("IM_2020"), paste0("GM_2020"))

# Se cambian los levels a los grados de marginaci√≥n correspondientes
levels(DP2_2020[,25]) = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")
```


### L√≠mites de los estratos {-}

Se crea un data frame llamado `limites` que contiene los l√≠mites de ciertos intervalos para el a√±o `2020`. Cada columna contiene una combinaci√≥n de:   
- El valor m√≠nimo del √≠ndice de marginaci√≥n (`IM:`) para el a√±o correspondiente.  
- Los valores de los l√≠mites de los estratos (`bh`) calculados previamente.  
- El valor m√°ximo del √≠ndice de marginaci√≥n (`IM_`) para el a√±o correspondiente.  

```{r}
limites <- data.frame("2020" = c(min(DP2_2020$IM_2020), strata.DP2$bh, max(DP2_2020$IM_2020)))
```


```{r, echo = FALSE}
tabla <- limites %>%
          t()  %>%
           as.data.frame() %>%
            mutate_if(is.numeric, round, digits = 2) %>%
             tibble::rownames_to_column(.data = .) %>% 
              mutate(ANIO = c("2020"),
                     `Muy alto` = paste("[", V1, "-", V2, "]"),
                     `Alto` = paste("(", V2, "-", V3, "]"),
                     `Medio` = paste("(", V3, "-", V4, "]"),
                     `Bajo` = paste("(", V4, "-", V5, "]"),
                     `Muy bajo` = paste("(", V5, "-", V6, "]")) %>%
               select(., c(8:13))

tabla %>% 
 rename("A√ëO" = "ANIO") %>%
  gt(rowname_col = c("A√ëO")) %>%
   tab_header(title = "L√≠mite de los estratos") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10) %>%
     tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
      cols_label(A√ëO = md("**A√ëO**"), 
                 `Muy alto` = md("**Muy alto**"),
                 `Alto` = md("**Alto**"),
                 `Medio` = md("**Medio**"),
                 `Bajo` = md("**Bajo**"),
                 `Muy bajo` = md("**Muy bajo**")) %>%
      as_raw_html() 
```



<!--chapter:end:05-Estratificacion.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# √çndice normalizado  {.unlisted .unnumbered}

Otra forma de apreciar el √≠ndice de marginaci√≥n es normalizando sus valores para ver objetivamente la evoluci√≥n de cada unidad territorial (Somarriba et al. 2013). La normalizaci√≥n se realiza utilizando un cambio de escala conocido como normalizaci√≥n m√≠nima-m√°xima. Con este procedimiento el √≠ndice de marginaci√≥n se escala a valores relativos con un rango de entre cero y uno, lo cual permite su comparaci√≥n num√©rica y le da una propiedad adicional al √≠ndice de marginaci√≥n. Al mismo tiempo, la normalizaci√≥n determina el mismo sentido que el √≠ndice obtenido por el m√©todo DP2, donde los valores cercanos a cero implican mayor marginaci√≥n.  

El proceso de normalizaci√≥n consiste en:

$${DP}_2normalizado=\frac{{DP}_2^i-\min({DP}_2)}{\max({DP}_2)-\min({DP}_2)},$$
donde:

$\circ \: {DP}_{2}^{i}$: es el valor del √≠ndice de marginaci√≥n de la localidad $i$,   
$\circ \: min ({DP}_{2})$: es el valor m√≠nimo o peor escenario que puede tomar el √≠ndice, y   
$\circ \: max ({DP}_{2})$: es el valor m√°ximo u objetivo que puede tomar el √≠ndice.  


## Desviaci√≥n est√°ndar de los indicadores simples  {-}

**Varianza muestral insesgada**    
**Estimado insesgado de la varianza poblacional**      

$$s^{2} = \frac{1}{n-1}\left(x_{i}-\bar{x}\right)^{2} = \frac{\sum_{i=1}^{n}(x_{i}^{2})}{n-1} - \frac{\sum_{i=1}^{n}(x_{i})^{2}}{(n-1)\: n } = \left(\frac{n-1}{n}\right)s_{n}^{2} $$

Se calcula la desviaci√≥n est√°ndar muestral y su inversa para un conjunto de indicadores simples. Para cada elemento:   
- Extrae las columnas 13 a 23 del data frame correspondiente (`DP2_2020`).  
- Calcula la desviaci√≥n est√°ndar para cada una de estas columnas.  
- Ajusta la desviaci√≥n est√°ndar para obtener la desviaci√≥n est√°ndar muestral.  
- Calcula la inversa de la desviaci√≥n est√°ndar muestral.  
- Almacena los resultados en un data frame `desvest`. 

```{r}
# Desviaci√≥n estandar de los indicadores
desvest <- as.matrix(apply(DP2_2020[13:23], MARGIN = 2, sd)) %>%
            as.data.frame() %>%
             rename("desvest" = "V1") %>%
              mutate(sd_muestral = .$desvest * (sqrt((dim(DP2_2020[13:23])[1] - 1)/dim(DP2_2020[13:23])[1]))) %>%
               mutate(desvest.inversa = 1/(.$sd_muestral))

```


```{r, echo = FALSE}
# Tabla
tabla <- desvest %>%
          tibble::rownames_to_column()

tabla %>%
 gt() %>%
  tab_header(title = "Desviaci√≥n est√°ndar") %>% 
   tab_options(heading.title.font.size = 14, 
               heading.align = "center",
               heading.padding = 5,
               heading.subtitle.font.size = 12,
               table.align = "center",
               table.font.names = 'Century Gothic',
               table.font.size = 10,
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "center",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     cols_label(`desvest` = md("**Desviaci√≥n est√°ndar**"), 
                `sd_muestral` = md("**Desviaci√≥n est√°ndar  muestral**"),
                `desvest.inversa` = md("**Desviaci√≥n estandar m. inversa**")) %>%
      fmt_number(columns = c(2:4), decimals = 3) %>%
      as_raw_html()
```

## Escenarios extremos {-}

Para este tipo de c√°lculo es necesario conocer los puntos m√°s extremos que puede tomar el √≠ndice en el a√±o de observaci√≥n. De antemano, se sabe que cada indicador simple toma valores de cero a 100 y, adem√°s, el m√©todo DP2 ya proporcion√≥ el orden de entrada de las variables. Usando estos criterios se estiman los puntos focales extremos que puede tomar el √≠ndice de marginaci√≥n. Se sabe que la peor situaci√≥n es cuando una unidad de an√°lisis toca todos y cada uno de los valores m√≠nimos del vector base de referencia com√∫n, esto ser√≠a el peor escenario de marginaci√≥n y tomar√≠a un valor de cero. En sentido contrario, el valor m√°ximo ser√≠a la situaci√≥n con la menor marginaci√≥n.   

**Escenarios del m√≠nimo y m√°ximo valor en el √≠ndice DP2**  

Se calculan los valores m√≠nimo y m√°ximo del √≠ndice `DP2` para diferentes escenarios y a√±os. Para cada elemento, se calcula:   
- `Valor m√≠nimo`: Calcula la diferencia absoluta entre minRV_2010 y vector_minimo, ajusta con la inversa de la desviaci√≥n est√°ndar muestral y los factores de correcci√≥n, y suma las filas para obtener el DP2.   
- `Valor m√°ximo`: Calcula la diferencia absoluta entre minRV_2010 y un vector de ceros (vector_maximo), ajusta con la inversa de la desviaci√≥n est√°ndar muestral y los factores de correcci√≥n, y suma las filas para obtener el DP2.    


```{r}
## M√≠nimo valor del DP2
vector_minimo <- minRV_2020
minimo <- abs(vector_minimo - minRV_2020) * desvest$desvest.inversa *
           ind_2020$correction_factors[names(DP2_datos_2020)] %>%
            t() %>%
             as.data.frame() 

minimo <- data.frame(A√ëO = 2020, Escenario = "M√≠nimo", minimo, DP2 = rowSums(minimo))
  
## M√°ximo valor del DP2   
vector_maximo <- rep(0, length(minRV_2020)) # Cuando los indicadores valen cero 
maximo <- abs(vector_maximo - minRV_2020) * desvest$desvest.inversa *
           ind_2020$correction_factors[names(DP2_datos_2020)] %>%
            t() %>%
             as.data.frame() 
maximo <- data.frame(A√ëO = 2020, Escenario = "M√°ximo", maximo, DP2 = rowSums(maximo))
```


## √çndice normalizado {-}

**Se guarda la base de datos con el √≠ndice normalizado**   

Se calcula un nuevo indicador denominado `IMN para el a√±o `2020`, normalizando el √≠ndice DP2 entre sus valores m√≠nimos y m√°ximos.    

```{r}
DP2_2020 <- DP2_2020 %>%  
             mutate(IMN_2020 = (.$IM_2020 - minimo$DP2)/(maximo$DP2 - minimo$DP2))
```


::: {style="height:400px;overflow:auto;"}
```{r, echo=FALSE}
#Tabla final
DP2_2020 %>% 
 rename("A√ëO" = "ANIO") %>%
  slice(1:20) %>%
  gt() %>%
   tab_header(title = "√çndice de marginaci√≥n a nivel colonia, 2020") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                column_labels.font.weight = "bold",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
      fmt_integer(columns = "POB_TOT", sep_mark = " ") %>%
       fmt_number(columns = c(13:23), decimals = 1) %>%
        fmt_number(columns = c(24, 26), decimals = 3) %>%
         cols_width(starts_with("POB") ~ px(100), 
                    starts_with("NOM") ~ px(200), 
                    starts_with("NOM_COLONIA") ~ px(260), 
                    everything() ~ px(60)) %>%
           as_raw_html()
```
:::



 
 <\br>
```{r, eval = FALSE}
#Tabla final
save(DP2_2020, file = paste0(here::here(), "/Output/IMC_2020.RData"))
```


<!--chapter:end:06_Normalizacion.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Validaci√≥n de datos  {.unlisted .unnumbered}

## Orden de entrada de las variables  {-}

**Se crea un data.frame de acuerdo al orden de importancia de las variables**   

Dependiendo del proceso, el `DP2` adoptar√° diferentes valores. Por lo tanto, es importante que el m√©todo de como resultado un orden de entrada √∫nico de los indicadores parciales.     

```{r}
Variables_sort <- ind_2020$variables_sort
```

```{r, echo = FALSE}
tabla <- Variables_sort %>%
          as.data.frame() %>%
           rename("Ind_2020" = ".")

tabla %>%
 gt() %>%
  tab_header(title = "Variables sort") %>%
   tab_options(heading.title.font.size = 14, 
               heading.align = "center",
               heading.subtitle.font.size = 12,
               table.align = "center",
               table.font.names = 'Century Gothic',
               table.font.size = 10,
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "center",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
      cols_width(everything() ~ px(80)) %>%
       as_raw_html() 
```


## Coeficiente de correlaci√≥n {-}  

El coeficiente de correlaci√≥n es una medida que se utiliza para jerarquizar a los indicadores simples de acuerdo con el grado de correlaci√≥n absoluta con respecto al indicador sint√©tico resultante, es decir, ayuda a visualizar que variable tiene un mejor o peor apego con el fen√≥meno.       

**Se crea un data.frame de acuerdo a la correlaci√≥n de cada variable con el indicador sint√©tico (DP2)**   

```{r}
cor.coeff <- ind_2020$cor.coeff
colnames(cor.coeff) <- c("cor.coeff")
```


```{r, echo = FALSE}
tabla <- cor.coeff %>%
          as.data.frame() %>%
          tibble::rownames_to_column(var = "Ind_2020")

tabla %>%
  gt() %>%
   tab_header(title = "Correlation Coefficient") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       fmt_number(columns = c(2), decimals = 3) %>% 
        cols_label(`Ind_2020` = md("**Ind_2020**"), 
                   `cor.coeff` = md("**cor.coeff**")) %>%
          cols_width(everything() ~ px(80)) %>%
           as_raw_html()           
```

## Factor de corrector  {-}

El factor corrector, como se mencion√≥ anteriormente, indica la proporci√≥n de informaci√≥n con la que contribuye el indicador simple al nuevo √≠ndice sint√©tico, adem√°s, evita la duplicidad e incorpora informaci√≥n √∫til que retiene cada indicador simple.        

**Se crea un data.frame de acuerdo al factor corrector de cada indicador parcial**

```{r}
correction_factors <- ind_2020$correction_factors %>% 
                       as.data.frame() %>%
                        rename("Correction Factor" = ".")
```


```{r, echo = FALSE}
tabla <- correction_factors %>%
          as.data.frame() %>%
           tibble::rownames_to_column(var = "Ind_2020")

tabla %>%
  gt() %>%
   tab_header(title = "Correction Factors") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       fmt_number(columns = c(2), decimals = 3) %>% 
        cols_label(`Ind_2020` = md("**Ind_2020**"), 
                   `Correction Factor` = md("**Correction Factor**")) %>%                      
         cols_width(everything() ~ px(80)) %>%
          as_raw_html()        
```


## Coeficiente de Discriminaci√≥n  {-}

El coeficiente de discriminaci√≥n de Ivanovic mide el poder discriminante de la variable $j$ en el conjunto de observaciones $i$. 

$$CD_{j}=\frac{2}{m\left(m-1\right)}\sum_{i,l>i}^{k_{j}}m_{ij}m_{lj}\left|\frac{x_{ij}-x_{lj}}{{\overline{X}}_{i}}\right|$$

donde: 

$\circ\:m_{ij}$: El n√∫mero de observaciones de la variable $x_{j}$    
$\circ\:k_{j}$: El n√∫mero de diferentes valores que toma $x_{i}$ en el conjunto $j$.     


Esta medida est√° comprendida entre $[0, 2]$. Si una variable toma el mismo valor para todos los estados, el `CD` vale cero, indicando que posee un valor nulo de poder discriminante. Por el contrario, si una variable toma el valor te√≥rico de m√°ximo poder discriminante, el discriminante de la variable es total.   

**Se crea un data.frame de acuerdo al Coeficiente de discriminaci√≥n (CD) de cada indicador parcial**

```{r}
discrimination_coefficient <- ind_2020$discrimination.coefficient %>% 
                               as.data.frame() %>%
                                rename("Discrimination Coefficient" = ".")
```


```{r, echo = FALSE}
tabla <- discrimination_coefficient %>%
          as.data.frame() %>%
           tibble::rownames_to_column(var = "Ind_2020")
tabla %>%
 gt() %>%
  tab_header(title = "Discrimination Coefficient") %>%
   tab_options(heading.title.font.size = 14, 
               heading.align = "center",
               heading.subtitle.font.size = 12,
               table.align = "center",
               table.font.names = 'Century Gothic',
               table.font.size = 10,
               data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       fmt_number(columns = c(2), decimals = 3) %>% 
        cols_label(`Ind_2020` = md("**Ind_2020**"),
                   `Discrimination Coefficient` = md("**Discrimination Coefficient**")) %>%
         cols_width(everything() ~ px(80)) %>%
          as_raw_html()         
```

## ‚ÄúCantidad de Informaci√≥n Global de Ivanovic Pena Relativa Individual‚Äù {-}

$$\alpha_{i}=\frac{CD_{i}\left(1-R^{2}_{i,i-1,...,1} \right)}{\sum_{i=1}^{n}CD_{i} \left(1-R^{2}_{i,i-1,...,1} \right)}$$
Esta medida, comprendida entre 0 y 1, combina la informaci√≥n √∫til y el poder discriminante de cada indicador simple y mide la cantidad de informaci√≥n (combinada) relativa que aporta individualmente cada indicador simple, cuando entra de forma ordenada a formar parte del indicador sint√©tico DP2. La suma de todos los valores de $\alpha_{i}$ es la unidad. [Zarsosa 1996, p√°gs 158-174]      

```{r}
alpha <- correction_factors * discrimination_coefficient/sum(correction_factors * discrimination_coefficient)
colnames(alpha) <- c("alpha")
```

```{r, echo = FALSE}
tabla <- alpha %>%
          as.data.frame() %>%
           tibble::rownames_to_column(var = "Ind_2020")

tabla %>%
  gt() %>%
   tab_header(title = md("Cantidad de Informaci√≥n Global de Ivanovic Pena Relativa Individual")) %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       fmt_number(columns = c(2), decimals = 3) %>% 
       cols_label(`Ind_2020` = md("**Ind_2020**"),
                  `alpha` = md("**alpha**")) %>%
         cols_width(everything() ~ px(80)) %>%
          as_raw_html()        
```


<!--chapter:end:07-Validacion.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Resumen  {.unlisted .unnumbered}

```{r, echo = FALSE}
load(file = paste0(here::here(), "/Output/IMC_2020.RData"))

p <- DP2_2020 %>%
      group_by(GM_2020) %>%
       summarise(POB_TOT = sum(POB_TOT),
                 GM = n())

tabla <- p %>%
          janitor::adorn_totals(fill = "-", where = "row")

tabla %>% 
 gt() %>%
  tab_header(title = "Nacional: Poblaci√≥n y unidades geograficas seg√∫n el √≠ndice de marginaci√≥n, 2020") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = 'Century Gothic',
               table.align = "center",
               table.font.size = 10,
               data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
     tab_style(style = list(cell_text(weight = 'bold')),
               locations = cells_body(columns = everything(), rows = tidyselect::last_col())) %>%
      cols_label(`POB_TOT` = md("**Poblaci√≥n 2020**"),
                 `GM` = md("**Colonias**"),
                 `GM_2020` = md("**Grados**")) %>%
       fmt_integer(columns = c(2:3), sep_mark = " ") %>%
        tab_spanner(label = "2020",
                    columns = c(2:3)) %>%
         as_raw_html() 
```



## Mapa a nivel colonia {-}


```{r, echo=FALSE, out.width='100%', warning=FALSE, message=FALSE, eval = FALSE}
p <- readRDS(file = paste0(here::here(),"/Output/Mapa.rds"))
p
```


## Comparaci√≥n en el tiempo {-}

<div style="height:500px;">
```{r, echo=FALSE, out.width='100%', eval = FALSE}
readRDS(paste0(here::here(), "/Output/Mapas_2010-2020.rds"))
```
</div> 

<!--chapter:end:08-Resumen.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Referencias  {.unlisted .unnumbered}

```{r echo = FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
``` 

Dalenius, T. (1950). The problem of optimum stratification. Scandinavian Actuarial J., 3-4, 203-13. Recuperado de: https://doi.org/10.1080/03461238.1950.10432042    
__________ y Hodges, J. L., Jr. (1959). Minimum variance stratification. Journal of the American Statistical Association, 54, 88-101.      
Gunning, P. y Horgan, J. M. (2004). A new algorithm for the construction of stratum boundaries in skewed populations. Survey Methodology, 30 (2), 159‚Äì166.   

INEGI [Instituto Nacional de Estad√≠stica y Geograf√≠a]. (2009). Censo de Poblaci√≥n y Vivienda 2010. Manual de
cartograf√≠a geoestad√≠stica. Recuperado de: https://www.inegi.org.mx/contenidos/temas/mapas/mg/metadatos/manual_cartografia_censal.pdf   
__________. (2010). Sistema Nacional de Informaci√≥n Estad√≠stica y Geogr√°fica: Laboratorio de Microdatos. Censo
de Poblaci√≥n y Vivienda 2010.   
__________. (2021a). Sistema Nacional de Informaci√≥n Estad√≠stica y Geogr√°fica: Laboratorio de Microdatos. Censo
de Poblaci√≥n y Vivienda 2020.    
__________. (2021b). Marco Geoestad√≠stico Nacional 2020. Censo de Poblaci√≥n y Vivienda 2020. Recuperado de:
https://www.inegi.org.mx/app/biblioteca/ficha.html?upc=889463807469    

Pena Trapero, J. B. (1977). Problemas de la medici√≥n del bienestar y conceptos afines. Una aplicaci√≥n al Caso Espa√±ol. I. N. E: Madrid.   

Somarriba, N. y Pena, B. (2009). Synthetic Indicators of Quality of Life in Europe. Social Indicators Research. Recuperado de: https://doi.org/10.1007/s11205-008-9356-y    
__________, Zarzosa, P. y Pena, T. (2013). La calidad de vida en la Uni√≥n Europea. Un an√°lisis temporal por medio de indicadores sint√©ticos.    Congreso de la Asociaci√≥n Espa√±ola de Ciencia Regional. XXXIX Reuni√≥n de Estudios Regionales. Smart regions for a smarter growth strategy: new challenges of Regional Policy and potentials of cities to overcome a worldwide economic crisis. Recuperado de:  https://old.reunionesdeestudiosregionales.org/Oviedo2013/htdocs/pdf/p851.pdf     

Zarzosa, P. (1996). Aproximaci√≥n a la medici√≥n del bienestar social. Secretario de Publicaciones: Valladolid.    
__________. (2009). Estimaci√≥n de la pobreza en las comunidades aut√≥nomas espa√±olas, mediante la distancia DP2 de Pena. Estudios de Econom√≠a Aplicada, 27 (2), 397‚Äì416.
__________. (2012). The Social Welfare in Spain before the Crisis: Territorial and Chronological Analysis. International Journal of Advances in Management and Economics 1 (4), 165-171.   
__________ y Somarriba, N. (2013). An Assessment of Social Welfare in Spain: Territorial Analysis Using a Synthetic Welfare Indicator. Social Indicators Research, 111, 1-23.    

 

```{r, collapse=FALSE}
sesion_info <- devtools::session_info()
```


```{r, echo = FALSE}
kable(dplyr::select(tibble::as_tibble(sesion_info$packages %>% dplyr::filter(attached == TRUE)),
                    c(package, loadedversion, source))) %>%
   kable_classic(full_width = TRUE, html_font = "Century Gothic", font_size = 10) 
```

<!--chapter:end:09-Bibliografias.Rmd-->

