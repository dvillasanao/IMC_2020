--- 
title: "Índice de marginación a nivel colonia 2020"
author: "Diana Villasana Ocampo"
site: bookdown::bookdown_site
documentclass: book
bibliography: [book.bib, packages.bib]
url: 'https://github.com/dvillasanao/IMC_2020'
# cover-image: path to the social sharing image like images/cover.jpg
description: |
  This is a minimal example of using the bookdown package to write a book.
  The HTML output format for this example is bookdown::bs4_book,
  set in the _output.yml file.
biblio-style: apalike
csl: chicago-fullnote-bibliography.csl
---
```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```

# Índice de marginación a nivel colonia  {.unlisted .unnumbered}

El índice de marginación a nivel de colonia urbana, elaborado por el Consejo Nacional de Población (CONAPO) en México, es una herramienta crucial para comprender y abordar las desigualdades socioeconómicas en el ámbito urbano. Este índice proporciona información detallada sobre las condiciones de marginación en las colonias de las ciudades, lo que permite identificar las áreas con mayores necesidades y focalizar los esfuerzos de desarrollo y políticas públicas de manera más efectiva.   

Para el año 2020, se dio a la tarea de estimar por primera vez un Índice de marginación urbana por colonia, como una forma de ofrecer un producto que condensa once formas de exclusión de los beneficios del desarrollo y que permite observar territorialmente la intensidad de la marginación en las colonias de las urbes de México. Este índice se construye considerando múltiples dimensiones, como el acceso a servicios básicos, la vivienda, la educación, la salud, y infraestructura.    

Este índice tiene diversos propósitos:      

- **Identificación de colonias marginadas**: El índice permite identificar las colonias urbanas con mayores niveles de marginación y pobreza. Esto es fundamental para dirigir los recursos y programas hacia las áreas que requieren una atención prioritaria.      

- **Distribución de recursos**: El índice de marginación a nivel de colonia ayuda a asignar recursos de manera equitativa, tanto a nivel municipal como estatal y federal. Permite que los fondos públicos se destinen de manera adecuada a las colonias con mayores necesidades, garantizando una distribución más justa de los recursos.    

- **Planificación urbana y desarrollo local**: El índice de marginación es utilizado en la planificación del desarrollo urbano y local. Ayuda a identificar las áreas que requieren inversiones en infraestructura, servicios básicos y equipamiento comunitario, fomentando un desarrollo más equilibrado y sostenible.   

- **Evaluación de políticas públicas**: El índice de marginación también permite evaluar el impacto de las políticas y programas implementados para reducir la pobreza y la desigualdad en las colonias urbanas. Ayuda a monitorear el progreso a lo largo del tiempo y realizar ajustes necesarios en las estrategias en curso.    

La importancia del índice de marginación a nivel de colonia urbana en las políticas públicas radica en su capacidad para proporcionar una visión detallada y precisa de las condiciones de marginación en las áreas urbanas. Permite una toma de decisiones más informada y basada en evidencia, facilitando la asignación adecuada de recursos y programas para abordar las desigualdades y promover el desarrollo inclusivo en las colonias más necesitadas. Además, al monitorear los cambios en el índice con el tiempo, se puede evaluar el impacto de las políticas implementadas y realizar ajustes necesarios para lograr una mayor equidad y bienestar en las áreas urbanas de México.     

**Base de datos** de los tres años se encuentran disponibles en la página oficial de [CONAPO](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372)   

**Datos abiertos de México** [datos.gob.mx](https://datos.gob.mx/busca/dataset/indice-de-marginacion-carencias-poblacionales-por-localidad-municipio-y-entidad)   

**Publicación** [Índice De Marginación Por Entidad Federativa Y Municipio 2020](https://www.gob.mx/conapo/documentos/indices-de-marginacion-2020-284372).    

**Índice de marginación a nivel estatal** [Bookdown](https://dvillasanao.github.io/IME_2010_2020/)   
**Índice de marginación a nivel municipal** [Bookdown](https://dvillasanao.github.io/IMM_2010-2020/)   
**Índice de marginación a nivel localidad** [Bookdown](https://dvillasanao.github.io/IML_2010_2020/)   
**Índice de marginación a nivel AGEB** [Bookdown](https://dvillasanao.github.io/IML_2010-2020/)   
**Índice de marginación a nivel Colonia** [Bookdown](https://dvillasanao.github.io/IMC_2020/)     

```{r, include=FALSE}
# automatically create a bib database for R packages
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, cache = TRUE, 
                       eval = TRUE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(rprojroot::find_rstudio_root_file())
```  

```{r, echo = FALSE, results=FALSE}
#Font Stlye
require(showtext)
library(extrafont)
# activar showtext
windowsFonts()
#Century Gothic
```


```{r, echo = FALSE, results=FALSE}
# Librerías que se usaron en el documento
require(Cairo)
require(ggplot2)
require(ggridges)
require(grDevices)
require(ggpubr)
require(dplyr)
require(p2distance)
require(stratification)
require(knitr)
require(magrittr)
require(kableExtra)
require(openxlsx)
require(tidyverse)
require(readxl)
require(psych)
require(stringr)
require(corrplot)
require(forcats)
require(gt)
require(rgdal)      
require(geojsonio)
require(jsonlite)
require(leaflet)
require(htmlwidgets)
require(leaflet.extras)
require(mapview)
require(leaflet.providers)
```

```{r include=FALSE, eval=FALSE}
# automatically create a bib database for R packages
knitr::write_bib(c(
  .packages(), 'bookdown', 'knitr', 'rmarkdown', 'dp2distance', 'statification', 'corrplot'
), 'packages.bib')
```


```{r, echo = FALSE}
load(file = paste0(here::here(), "/Output/IMC_2020.RData"))

p <- DP2_2020 %>%
      group_by(GM_2020) %>%
       summarise(POB_TOT = sum(POB_TOT),
                 GM = n())

tabla <- p %>%
          janitor::adorn_totals(fill = "-", where = "row")

tabla %>% 
 gt() %>%
  tab_header(title = "Nacional: Población y unidades geograficas según el índice de marginación, 2020") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = 'Century Gothic',
               table.align = "center",
               table.font.size = 10,
               data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
     tab_style(style = list(cell_text(weight = 'bold')),
               locations = cells_body(columns = everything(), rows = tidyselect::last_col())) %>%
      cols_label(`POB_TOT` = md("**Población 2020**"),
                 `GM` = md("**Colonias**"),
                 `GM_2020` = md("**Grados**")) %>%
       fmt_integer(columns = c(2:3), sep_mark = " ") %>%
        tab_spanner(label = "2020",
                    columns = c(2:3)) %>%
         as_raw_html() 
```

<!--chapter:end:index.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Indicadores simples  {.unlisted .unnumbered}


### Porcentaje de población de 6 a 14 años que no asiste a la escuela $(I_{1}^{i})$ {-}     

El indicador se obtiene dividiendo el monto de población de 6 a 14 años que no asiste a la escuela entre la diferencia de la población total de 6 a 14 años y aquellos que no especificaron su condición de asistencia a la escuela:    

$$I_{1}^{i}=\frac{{PNS}^{i}_{6-14}}{{P}^{i}_{6-14}-{PNEAS}^{i}_{6-14}}\times100$$  

donde:   

$PNS^{i}_{6-14}$: es la población de 6 a 14 años que no asiste a la escuela,   
$P^{i}_{6-14}$: es la población total de 6 a 14 años, y   
$PNEAS^{i}_{6-14}$: es la población de 6 a 14 años que no especificó su condición de asistencia a la escuela.    

### 	Porcentaje de población de 15 años o más sin educación básica $(I_{2}^{i})$ {-}

El indicador mide la magnitud de la población sin educación básica completa. Su cálculo se realiza en dos etapas. En la primera, la población que no especificó su último grado aprobado en secundaria o en estudios técnicos o comerciales con primaria terminada, se distribuye entre la población que aprobó entre uno y dos grados en estos mismos niveles educativos, aplicando la siguiente fórmula:   

$${PSI}_{15+}^{i}={PSCI}_{15+}^i+\left[\frac{{PSCI}_{15+}^i}{{PSCI}_{15+}^i+{PSCC}_{15+}^i}\times{PNEGS}_{15+}^i\right]$$


donde:    

$P{SI}_{15+}^{i}$: es la población de 15 años o más que aprobó entre el primer y segundo grado de secundaria o estudios técnicos o comerciales con primaria terminada con los no especificados de estos niveles educativos ya distribuidos,  
${PSCI}_{15+}^{i}$: es la población de 15 años o más que declaró haber aprobado entre el primer y segundo grado de secundaria o estudios técnicos o comerciales con primaria terminada,  
${PSCC}_{15+}^{i}$: es la población de 15 años o más que cursó el tercer grado en secundaria o tres o cuatro grados en estudios técnicos o comerciales con primaria terminada, y  
${PNEGS}_{15+}^{i}$: es la población de 15 años o más que no especificó su último grado cursado en secundaria o en estudios técnicos o comerciales con primaria terminada.  

Con el dato de la población con estudios truncos en secundaria o en estudios técnicos o comerciales con primaria terminada, se procedió a calcular el indicador de porcentaje de población sin educación básica. Este porcentaje se calcula dividiendo la población de 15 años o más sin educación básica, entre la diferencia de la población total de 15 años o más y aquellos que no especificaron su nivel educativo:   

$$I_{2}^{i}=\frac{{PSIN}_{15+}^i+{PPI}_{15+}^i+{PSI}_{15+}^i}{P_{15+}^i-{PNEIN}_{15+}^i}\times100$$

donde:

${PSIN}_{15+}^{i}$: es la población de 15 años o más sin instrucción,  
${PPI}_{15+}^{i}$: es la población de 15 años o más con algún grado en educación primaria,  
${PSI}_{15+}^{i}$: es la población de 15 años o más con nivel incompleto de secundaria o estudios técnicos o comerciales con primaria terminada,   
$P_{15+}^{i}$: es la población total de 15 años o más, y   
${PNEIN}_{15+}^{i}$: es la población de 15 años o más que no especificó su nivel de instrucción.   


### Porcentaje de población sin derechohabiencia a los servicios de salud $(I_{3}^{i})$ {-}    

En este indicador se identifica a la población sin derechohabiencia a los servicios de salud y se divide entre el total de población menos el número de personas que no especificó su condición de derechohabiencia a los servicios de salud:  

$$I_{3}^{i}=\frac{{PSD}^{i}}{{P}^{i}-{PNESD}^{i}}\times100$$  

donde:    
${PSD}^{i}$: es la población sin derechohabiencia a los servicios de salud,     
${P}^{i}$: es la población total, y    
${PNESD}^{i}$: es la población que no especificó su condición de derechohabiencia a los servicios de salud.    

### Porcentaje de ocupantes en viviendas particulares sin drenaje ni sanitario $(I_{4}^{i})$ {-} 

Este porcentaje se obtiene al dividir el número de ocupantes de viviendas particulares sin drenaje ni sanitario, entre el número de ocupantes en viviendas particulares, menos el número de ocupantes de viviendas particulares en donde no se especificó la disponibilidad de drenaje ni sanitario:  

$$I_{4}^{i}=\frac{{OVSDS}^{i}}{{OVP}^{i}-{ONEDS}^{i}}\times100$$


donde:

${OVSDS}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de drenaje ni sanitario,   
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEDS}^{i}$: son los ocupantes de viviendas particulares en donde no se especificó la disponibilidad de drenaje ni sanitario.    

### Porcentaje de ocupantes en viviendas particulares sin energía eléctrica $(I_{5}^{i})$ {-}

Este indicador se obtiene al dividir el número de ocupantes de viviendas particulares sin disponibilidad de energía eléctrica, entre el número de ocupantes en viviendas particulares menos el número de ocupantes de viviendas particulares en donde no se especificó la existencia de luz eléctrica:   

$$I_{5}^{i}=\frac{{OSEE}^i}{{OVP}^{i}-{ONEEE}^{i}}\times100$$  
donde:   

${OVSDS}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de drenaje ni sanitario,  
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEDS}^{i}$: son los ocupantes de viviendas particulares en donde no se especificó la disponibilidad de drenaje ni sanitario.   


### Porcentaje de ocupantes en viviendas particulares sin agua entubada $(I_{6}^{i})$ {-}     
	
Para obtener este indicador se divide el número de ocupantes en viviendas particulares que no disponen de agua entubada, entre la diferencia del total de ocupantes en viviendas particulares y el total de ocupantes en viviendas en donde no se especificó la disponibilidad de agua entubada:   

$$I_{6}^{i}=\frac{{OSAE}^i}{{OVP}^i-{ONEAE}^i}\times100$$   

donde:  

${OSAE}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de agua entubada,  
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEAE}^{i}$: son los ocupantes de viviendas particulares en donde no se especificó la disponibilidad de agua entubada.   


### Porcentaje de ocupantes en viviendas particulares con piso de tierra $(I_{7}^{i})$ {-}  

En este indicador se identifican los ocupantes de viviendas particulares con piso de tierra y se divide entre el total de ocupantes en viviendas particulares, menos el número de ocupantes de viviendas particulares en donde no se especificó el material predominante en pisos:    

$$I_{7}^{i}=\frac{{OPT}^i}{{OVP}^i-{ONEMP}^i}\times100$$    

donde:   

${OPT}^{i}$: son los ocupantes de viviendas particulares con piso de tierra,    
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEMP}^{i}$: son los ocupantes de viviendas particulares en las que no se especificó el material predominante en pisos.    

### Porcentaje de ocupantes en viviendas particulares con hacinamiento $(I_{8}^{i})$ {-}  

El procedimiento para el cálculo de este indicador constó de dos etapas. Primero, en cada vivienda particular habitada se dividió el número de ocupantes entre el número de cuartos dormitorio, para identificar las viviendas con hacinamiento:    

$$OVHAC=\frac{OVP}{CDVP}$$   
donde:

$VHAC$: es la vivienda con hacinamiento,   
$OVP$: es el número de ocupantes que residen habitualmente una vivienda particular, y    
$CDVP$: es el número de cuartos dormitorio en una vivienda particular.   
	
En la segunda fase de cálculo, se dividió el número de ocupantes en viviendas particulares con hacinamiento, entre el total de ocupantes en viviendas particulares habitadas menos el número de ocupantes en viviendas particulares habitadas donde no se especificó el número de cuartos dormitorio:     

$$I_{8}^{i}=\frac{O{VHAC}^i}{{OVP}^i-{ONECD}^i}\times100$$    

donde:

${OVHAC}^{i}$: son los ocupantes en viviendas particulares con hacinamiento,   
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONECD}^{i}$: son los ocupantes en viviendas particulares en donde no se especificó el número de cuartos dormitorio.     

### Porcentaje de ocupantes en viviendas particulares sin refrigerador $(I_{9}^{i})$ {-}   
	
En este indicador se identifican los ocupantes en viviendas particulares que no disponen de refrigerador y se divide entre el total de ocupantes en viviendas particulares menos los ocupantes en viviendas particulares que no especificaron la disponibilidad de refrigerador:    

$$I_{9}^{i}=\frac{{OSR}^i}{{OVP}^i-{ONER}^i}\times100$$  

donde:   

${OSR}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de refrigerador,     
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y    
${ONER}^{i}$: son los ocupantes de viviendas particulares en donde no se especificó la disponibilidad de refrigerador.   

###  Porcentaje de ocupantes en viviendas particulares sin internet $(I_{10}^{i})$ {-}    

El indicador se calculó dividiendo el número de ocupantes en viviendas particulares que no disponen de servicio de internet, entre el total de ocupantes en viviendas particulares menos los ocupantes en viviendas particulares donde no se especificó la disponibilidad de internet:   

$$I_{10}^{i}=\frac{{OSI}^i}{{OVP}^i-{ONEI}^i}\times100$$  
donde:
${OSI}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de internet,   
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEI}^{i}$: son los ocupantes de viviendas particulares en las que no se especificó la disponibilidad de internet.     


### Porcentaje de ocupantes en viviendas particulares sin celular $(I_{11}^{i})$ {-}    

Este indicador se obtiene dividiendo el número de ocupantes en viviendas particulares que no disponen de celular, entre el total de ocupantes en viviendas particulares menos los ocupantes en viviendas particulares que no especificaron la disponibilidad de celular:   

$$I_{11}^{i}=\frac{{OSC}^i}{{OVP}^i-{ONEC}^i}\times100$$  
donde:
${OSC}^{i}$: son los ocupantes de viviendas particulares sin disponibilidad de celular,    
${OVP}^{i}$: es el total de ocupantes en viviendas particulares, y   
${ONEC}^{i}$: son los ocupantes de viviendas particulares en las que no se especificó la disponibilidad de celular.    

**Indicadores simples**  

```{r}
Indicadores <- c(
                 'Porcentaje de población de 6 a 14 años que no asiste a la escuela', 
                 'Porcentaje de población de 15 años y más sin educación básica',
                 'Porcentaje de población sin derechohabiencia a los servicios de salud',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas sin drenaje ni excusado',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas sin energía eléctrica',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas sin agua entubada',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas con piso de tierra',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas con algún nivel de hacinamiento',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas sin refrigerador',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas sin internet',
                 'Porcentaje de ocupantes en viviendas particulares \n habitadas sin celular'
                 )
```
	




	

	
	
 




<!--chapter:end:01-Indicadores.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Base de datos {.unlisted .unnumbered}

El Índice de marginación urbana por colonia 2020 se desarrolló con información socioeconómica a nivel de AGEB urbana proveniente del Censo de Población y Vivienda 2020 mediante una petición de información al Laboratorio de Microdatos del INEGI (2010 y 2021a). Esta solicitud sirvió para la estimación de los índices de marginación de 50 790 AGEB urbanas. Con los datos absolutos de estas AGEB urbanas se estimaron los indicadores socioeconómicos a nivel de colonias. 

**A continuación, se carga la base de datos correspondiente al índice de marginación por colonia (2020).** 

```{r}
load(file = paste0(here::here(), "/Bases/IMC_2020.RData")) 
```

<div style="height:700px;overflow:auto;">
```{r, echo = FALSE}
require(gt)
tabla_2020 %>% 
 rename("AÑO" = "ANIO") %>%
  slice(1:20) %>%
    gt() %>%
     tab_header(title = "Indicadores simples de marginación",
                 subtitle = "2020") %>%
      fmt_number(columns = names(tabla_2020)[13:23], 
                  decimals = 2) %>%
       fmt_integer(columns = "POB_TOT", 
                    sep_mark = " ") %>%
        tab_options(heading.title.font.size = 14, 
                    heading.subtitle.font.size = 12,
                    table.font.names = 'Century Gothic',
                    table.font.size = 10,
                    data_row.padding = px(1)) %>%
         tab_style(style = list(cell_text(align = "left",
                                           weight = 'bold')),
                    locations = list(cells_title(groups = c("title")))) %>%
          tab_style(style = list(cell_text(align = "left")),
                     locations = list(cells_title(groups = c("subtitle")))) %>%
           cols_label(CVE_COL = md("**CVE_COL**"),
                      ID_COL = md("**ID_COL**"),
                      ID_INE_2020 = md("**ID_INE_2020**"),
                      NOM_COLONIA = md("**NOM_COLONIA**"),
                      CP = md("**CP**"),
                      CLASIF = md("**CLASIF**"),
                      CVE_ENT = md("**CVE_ENT**"),
                      NOM_ENT = md("**NOM_ENT**"), 
                      CVE_MUN = md("**CVE_MUN**"), 
                      NOM_MUN = md("**NOM_MUN**"),
                      POB_TOT = md("**POB_TOT**"), 
                      AÑO = md("**AÑO**"), 
                      P6A14NAE = md("**P6A14NAE**"),
                      SBASC = md("**SBASC**"),
                      PSDSS = md("**PSDSS**"),
                      OVSDE = md("**OVSDE**"),
                      OVSEE = md("**OVSEE**"),
                      OVSAE = md("**OVSAE**"),
                      OVPT= md("**OVPT**"),
                      OVHAC = md("**OVHAC**"),
                      OVSREF = md("**OVSREF**"),
                      OVSINT = md("**OVSINT**"),
                      OVSCEL = md("**OVSCEL**")) %>%
         cols_width(starts_with("POB") ~ px(80), 
                    starts_with("NOM") ~ px(180), 
                    starts_with("NOM_C") ~ px(360), 
                    everything() ~ px(60)) %>%
            as_raw_html() 
```
</div>

<!--chapter:end:02-Datos.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Análisis de correlaciones  {.unlisted .unnumbered}

La función `corrplot` en `R` es utilizada para crear matrices de correlación visualmente atractivas y fáciles de interpretar. Esta función es parte del paquete `corrplot`, que proporciona herramientas para visualizar y analizar matrices de correlación.   

La matriz de correlación es una tabla que muestra las correlaciones entre pares de variables. En análisis de datos, la correlación se utiliza para medir la relación entre dos variables. Puede ser útil para comprender cómo se relacionan diferentes variables entre sí y cómo afectan a otras variables en un conjunto de datos.   
 
```{r, fig.align='center', fig.width=12, fig.height=12, out.width='100%', eval = FALSE}
col2 <- colorRampPalette(c("#67001F", "#B2182B", "#D6604D", "#F4A582", "#FDDBC7", "#FFFFFF", "#D1E5F0", "#92C5DE","#4393C3", "#2166AC", "#053061"))
par(mfrow = c(1,1), family = "Century Gothic", mar = c(0.5, 0, 0, 0), cex.main = 3, col.main = "#053061")
#Análisis de correlaciones
corrplot(cor(tabla_2020[,13:23]) ,
          title = "2020",
           type = "upper",
            method = "color",
             col = col2(100),
              tl.col = "blue4",
               tl.offset = 0.1,
                tl.cex = 2.7,
                 tl.srt = 90,
                  cl.align.text = "c",
                   number.cex = 1.9,
                    cl.cex = 2.1,
                     addCoef.col = "white", # Add coefficient of correlatio
                      mar = c(10, 0, 2.5,0))
```

<a href="https://raw.githubusercontent.com/dvillasanao/IMC_2020/main/img/correlaciones_2020.png" data-lightbox="image-1" data-title="correlaciones">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
require(knitr)
knitr::include_graphics(paste0(here::here(), "/img/correlaciones_2020.png"))
```
</a>





<!--chapter:end:03-Correlaciones.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Método de Distancias $DP2$  {.unlisted .unnumbered}


José Bernardo Pena Trapero: `Problemas de la medición del bienestar y conceptos afines (1977)` 

Los métodos de distancias son enfoques utilizados para medir el bienestar o la calidad de vida de las personas a través de la comparación de diferentes dimensiones o indicadores. Estos métodos se basan en la idea de que el bienestar se puede evaluar considerando la distancia o diferencia entre los individuos en términos de ciertos atributos o variables relevantes.   
La Distancia $DP_{2}$, es un indicador sintético, definido por el profesor `J. Bernardo Pena Trapero`, basado en el concepto de distancia, construido, como su nombre indica para medir distancias entre unidades geográficas, o bien, también se puede aplicar a comparaciones tanto cronológicas como interespaciales.     
   

**Definición**

Sean:   

$\:\:\circ\:r$, el número de municipios;  
$\:\:\circ\:n$, el número de variables;  
$\:\:\circ\:x_{ij}$, el valor de la variable j en la AGEB $i$;  
$\:\:\circ\:\sigma_{j}$, La Desviación Típica de la variable $j$;   
$\:\:\circ\:R^{2}_{i,i-1,...,1}$ el Coeficiente de Determinación en la Regresión de $X_{i}$ sobre $X_{i-1},X_{i-2},...,X_{1}$. 

Se define la $Distancia-P_{2}$ de la forma:    

\begin{align}
DP_{2}=\sum^{n}_{i=1}\frac{d_{i}}{\sigma_{i}}(1-R^{2}_{i,i-1,...,1})\:\:;\;\;con \:\:R^{2}_{1}=0
\end{align}

Donde:     

$\:\:\circ\:d_{i} = d_{i}(r,*) = |x_{ri}-x_{*i}|$ |: es la distancia de la j-ésima variable del municipio $r$ con respecto a la base de referencia $x_{*}=(x_{*1}, x_{*2},..., x_{*n})$. Tomando como punto de referencia el valor mínimo de la variable, siendo esta la peor situación teórica,      

 $\:\:\circ\:\sigma_{i}$ : es la desviación estándar de la variable $𝑗$,     
 
 $\:\:\circ\:R^{2}_{i,i-1,...,1}$: es el coeficiente de determinación de la regresión del indicador parcial $𝑗$ con respecto a los otros indicadores $(𝑗−1,𝑗−2,…,1)$. Esta expresión es parte de la varianza del indicador parcial $I_{j}$ que se explica linealmente por el resto de los indicadores parciales,        

$\:\:\circ\:(1-R^{2}_{i,i-1,...,1})$): es el factor corrector que evita la duplicidad, al eliminar la información parcial de los indicadores ya contenidos en los indicadores precedentes, y     

$\:\:\circ\:R^{2}_{1}=0$; porque la primera componente aporta toda la información y al no existir un componente previo su ponderación es la unidad.  

El $DP_{2}$ cumple con las siguientes propiedades: no negatividad, homogeneidad, conmutatividad, desigualdad triangular, existencia y determinación, monotonía, unicidad, transitividad, no duplicidad de información, invariancia al cambio de origen y/o de escala en las unidades y exhaustividad.      


El orden de entrada de las variables   

```{r}
# Se multiplica por -1, debido a que son indicadores de carencia 
assign("DP2_datos_2020", -1 * tabla_2020[13:23])  
```

Para asegurar las propiedades del indicador sintético, un aumento en los indicadores simples implica un aumento en la carencia de los servicios, lo que implicaría una disminución de la calidad de vida, por lo que se multiplica cada indicador por **-1**, de esta forma, un aumento en la variable supone una mejora en la calidad de vida.    


## Base de referencia  {-}

Se define al valor de referencia para cada uno de los indicadores parciales, con la finalidad de hacer comparaciones entre las diferentes unidades espaciales (Colonias). Siendo este el valor mínimo de cada indicador simple como referencia, representado como la “situación no deseada”. Como resultado, un valor alto implicaría una distancia alejada con respecto a una situación teórica “situación no deseada”. Por lo tanto $d_{ij}$ mide la distancia entre el indicador parcial $j$ en la entidad $i$ y su valor de referencia.    

Se toma como base de referencia el valor del mínimo del año `2020`, ya que este tipo de cambio permitirá la comparabilidad en el tiempo.    

```{r}
#Base de referencia 2010 - 2020
minRV_2020 <- makeReferenceVector(X = DP2_datos_2020, 
                                   reference_vector_function = min)
```


```{r, echo = FALSE}
minRV <- minRV_2020 %>%
          as.data.frame() %>%
           tibble::rownames_to_column(.data = .) %>%
            dplyr::mutate(rowname = case_when(rowname %in% 1 ~ "2020")) %>%
             rename("ANIO" = "rowname")

minRV %>% 
  rename("AÑO" = "ANIO") %>%
   gt() %>%
    tab_header(title = "Base de referencia") %>%
     fmt_number(columns = names(tabla_2020)[13:23], 
                decimals = 2) %>%
      tab_options(heading.title.font.size = 14, 
                  heading.align = "center",
                  heading.subtitle.font.size = 12,
                  table.align = "center",
                  table.font.names = 'Century Gothic',
                  table.font.size = 10) %>%
       tab_style(style = list(cell_text(align = "center",
                                         weight = 'bold')),
                  locations = list(cells_title(groups = c("title")))) %>%
        tab_style(style = list(cell_text(align = "left")),
                   locations = list(cells_title(groups = c("subtitle")))) %>%
         cols_label(AÑO = md("**AÑO**"), 
                    P6A14NAE = md("**P6A14NAE**"),
                    SBASC = md("**SBASC**"),
                    PSDSS = md("**PSDSS**"),
                    OVSDE = md("**OVSDE**"),
                    OVSEE = md("**OVSEE**"),
                    OVSAE = md("**OVSAE**"),
                    OVPT= md("**OVPT**"),
                    OVHAC = md("**OVHAC**"),
                    OVSREF = md("**OVSREF**"),
                    OVSINT = md("**OVSINT**"),
                    OVSCEL = md("**OVSCEL**")) %>%
          as_raw_html() 
```



## Método de Distancia $DP_{2}$  {-}   

```{r, results=FALSE}
require(p2distance)
##Calculo del Método de Distancias DP2
ind_2020 <- p2distance(matriz = as.matrix(DP2_datos_2020), 
                        reference_vector = minRV_2020, 
                         iterations = 50)
```

**Total de iteraciones**

```{r, collapse=TRUE}
iteration <- ind_2020[["iteration"]]
```


```{r, echo=FALSE}
tabla <- iteration %>%
          as.data.frame() %>%
           tibble::rownames_to_column(.data = .) %>%
            dplyr::mutate(rowname = case_when(rowname %in% 1 ~ "2020")) %>%
              rename("ANIO" = "rowname",
                     "iteraciones" = ".")

tabla %>% 
 rename("AÑO" = "ANIO") %>%
  gt() %>%
   tab_header(title = "Número de iteraciones") %>%
    fmt_integer(columns = "iteraciones") %>%
     tab_options(heading.title.font.size = 14, 
                 heading.subtitle.font.size = 12,
                 table.font.names = 'Century Gothic',
                 table.align = "center",
                 table.font.size = 10,
                 data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "left",
                                        weight = 'bold')),
                 locations = list(cells_title(groups = c("title")))) %>%
       tab_style(style = list(cell_text(align = "left")),
                  locations = list(cells_title(groups = c("subtitle")))) %>%
        cols_label(AÑO = md("**AÑO**"), 
                   iteraciones = md("**Iteraciones**")) %>%
         as_raw_html() 
```




Se anexan los resultados a las bases de datos original

```{r}
DP2_2020 <- cbind(tabla_2020, ind_2020[["p2distance"]])
names(DP2_2020) <- c(names(DP2_2020)[1:23], paste0("IM_2020"))
```

<!--chapter:end:04-Distancias.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Método de estratificación  {.unlisted .unnumbered}

### Identificación de datos atípicos {-}   

Para hacer cumplir la definición de los límites en el método de estratificación [véase: `Método de estratificación de Dalenius & Hodges`] y el número óptimo de clases basados en la media aritmética, es importante la identificación de datos atípicos porque podrían ocasionar resultados poco adecuados. Para contrarrestar este problema, `Hubert y Vandervieren (2007)` proponen el método de caja, el cual toma en cuenta el grado de asimetría de un conjunto de datos.  

$$\left[Q_{1} - 1.5e^{-4MC} IQR; \hspace{0.5cm}  Q_{3} + 1.5e^{-4MC} IQR \right] \text{para } MC \geq 0$$
$$\left[Q_{1} - 1.5e^{-3MC} IQR; \hspace{0.5cm}  Q_{3} + 1.5e^{-3MC} IQR \right] \text{para } MC < 0$$
donde:   
$\circ \:𝑄_{1}$ 𝑦 $𝑄_{3}$: hacen referencia al primer y tercer cuartil, respectivamente; la diferencia entre estos dos valores da como resultado el valor de espacio intercuartil ($𝐼𝑄𝑅$), y    
$\circ \:𝑀𝐶 (𝑚𝑒𝑑𝑐𝑜𝑢𝑝𝑙𝑒)$: cuantifica el grado de asimetría de una muestra univariable ${𝑥_1,𝑥_2,… ,𝑥_𝑛}$.     

Se identifican los valores atípicos para cada conjunto de datos. 

- Se calculan los estadísticos de la columna del índice de marginación para cada conjunto de datos $DP2_{i}$ correspondientes al año y se asigna el resultado a una nueva variable denominada $outliers_i$.    

```{r}
assign(paste0("outliers_2020"), boxplot.stats(DP2_2020[,24]))
```

Se crea un data.frame que contiene el número de valores atípicos, su rango y el límite inferior para cada conjunto de datos.

```{r, echo = FALSE}
#Límites para el cálculo de estratificación a nivel localidad, 2020
p <- data.frame(n = length(outliers_2020$out), 
                rango = range(outliers_2020$out), 
                lim = outliers_2020$stats[1])
```

```{r, echo = FALSE}
tabla <- data.frame(outliers = p$n[1],
                    minimo = p$rango[1],
                    maximo = p$rango[2])   
tabla %>% 
 gt() %>%
   tab_header(title = "Límites para el cálculo de estratificación a nivel colonia, 2020") %>%
    fmt_number(columns = c(2:3), decimals = 3) %>%
    tab_options(heading.title.font.size = 14, 
                heading.subtitle.font.size = 12,
                table.font.names = 'Century Gothic',
                table.align = "center",
                table.font.size = 10,
                data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
                locations = list(cells_title(groups = c("subtitle")))) %>%  
      cols_label(outliers = md("**Valores atípicos**"), 
                minimo = md("**Mínimo**"),
                maximo = md("**Límite**")) %>%
       tab_spanner(label = "Rango",
                   columns = c(minimo, maximo)) %>%
         as_raw_html() 

```

Se identifican los casos extremos en el índice de marginación y se aplica el método de caja propuesto por `Hubert y Vandervieren`, concluyendo los límites con los que se debe trabajar.      

Se añade una nueva columna `IM_out`. Esta columna se calcula usando `if_else`, de la siguiente manera:   

- Si el valor de IM es mayor o igual al límite inferior de los valores no considerados outliers `(get(paste0("outliers_", i))$stats[1])`, entonces `IM_out` toma el valor de `IM`.   
- Si el valor de IM es menor que el límite inferior, entonces `IM_out` toma el valor del límite inferior, eliminando así los outliers.      


```{r}
## Se crea un índice ficticio, en la que se quitan los outliers   
DP2_2020 <- DP2_2020 %>%
             mutate(IM_out = ifelse(get(paste(colnames(DP2_2020))[24]) >= outliers_2020$stats[1],
                                    get(paste(colnames(DP2_2020))[24]),
                                    outliers_2020$stats[1]))
```


### Método de estratificación de Dalenius & Hodges {-}

`strata.cumrootf`: cumulative root frequency method by Dalenius and Hodges (1959). 

Con la obtención del índice de marginación a través del método DP2, los valores se clasificaron en cinco categorías ordinales con el método de Dalenius y Hodges (1959), para obtener el grado de marginación. Este método forma estratos de manera que la varianza sea mínima al interior de cada estrato y máxima entre cada uno de ellos, es decir, son lo más homogéneos posibles. Este procedimiento utiliza la raíz de las frecuencias acumuladas para la construcción de los estratos, por lo que se lleva a cabo para la división de la población en el estrato L. Esta es una solución aproximada de Dalenius y Hodges (1959) a las ecuaciones de Dalenius (1950). De acuerdo con Gunning y Horgan (2004), el límite superior de cada estrato se determinó con la siguiente expresión:  

$$Q = \frac{1}{L}\sum^{J}_{i=1}{\sqrt{f_{i}}}$$

Sea un conjunto de estratos determinados por su límite superior,

 $$Q,\ 2Q,\ \ldots,\ \left(L-1\right)Q,\ (L)Q.$$
donde:  

$\circ \:J$: es el número de clases dentro del grupo de la variable ordenada X,    
$\circ \:f_{i}\ \in(1,\ \ldots, J)$: es la frecuencia en cada clase  $J$, y  
$\circ \:L$: es el número de estratos.   


La eficiencia del método de la raíz de las frecuencias acumuladas depende principalmente del número de clases dentro del grupo de la variable ordenada. Sin embargo, no hay un procedimiento estándar sobre cómo elegir el mejor valor para el número de clases, siendo esto una limitante del método de Dalenius y Hodges. Para medir el efecto del número  de clases en la varianza de cada estrato se recurrió a un método iterativo para obtener un criterio de agrupación óptimo.    

Para establecer los límites de los estratos $(b_{1},\ \ldots,\ b_{L})$ que minimicen la varianza del estimador, se utiliza la asignación de Neyman para determinar el tamaño de muestra óptimo. Sea la varianza del estimador:    

$$V\left({\bar{x}}_{st}\right)=\ \sum_{h}\left(\frac{N_h}{N}\right)^2\frac{S_h^2}{n_h}\ $$
donde:

$\circ  \: S_{h}^{2}$: es la varianza poblacional en el estrato $h$,   
$\circ  \:n_{h}$: es el tamaño de muestra en el estrato $h$ utilizada por la asignación de Neyman, y 
$\circ  \:N_{h}$: es el total de elementos en el estrato $h$, sea $N=\sum_{h=1}^{L}{N_{h}}$.     

Si se asume que la distribución dentro de cada estrato se distribuye aproximadamente de manera uniforme, los límites se obtienen tomando intervalos iguales en la función de la raíz de las frecuencias acumuladas. Los límites se resuelven de manera iterativa:   

$$\frac{S_h^2+(b_h-{\bar{X}}_h)2}{S_h}=\frac{S_{h+1}^2+(b_h-{\bar{X}}_{h+1})2}{S_{h+1}}\ para\ h=1,\ \ldots.\ ,\ L-1$$
donde:

$\circ  \: b_{h}$: es el límite superior en el estrato $h$,   
$\circ  \: {\bar{X}}_{h}$: es la media poblacional en el estrato $h$, y   
$\circ  \: S_{h}^{2}$: es la varianza poblacional en el estrato $h$.      

El requisito de precisión, generalmente se establece cuando el coeficiente de variación sea igual a un nivel especificado entre 1 y 10 por ciento (Hidiroglou y Kozak, 2018).     

## Número óptimo de clases del método de Dalenius & Hodge {-}  

`alloc` lista que especifica el esquema de asignación. La lista debe contener 3 números para los 3 exponentes q1, q2 y q3 en el esquema de asignación general (ver paquete de `stratification`). El valor predeterminado es la asignación de **Neyman** (q1 = q3 = 0.5 y q2 = 0)   

A continuación, se realiza un análisis de estratificación sobre los diferentes años, usando la función `strata.cumrootf()`, almacenando los resultados de errores estándar, medias y varianzas en matrices que luego se guardan en listas.   

```{r, results=FALSE, warning=FALSE, eval = FALSE}
iteraciones <- 1000
start.time <- Sys.time()
i <- 1
sd <- matrix(NA, nrow = (iteraciones), ncol = 3)
meanh <- matrix(NA, nrow = (iteraciones), ncol = 6)
varh <- matrix(NA, nrow = (iteraciones), ncol = 6)
for (n in seq(5, iteraciones, 1)){
     cum <- strata.cumrootf(x = DP2_2020[,25], CV = 0.05 , Ls = 5, alloc = c(0.5, 0, 0.5), nclass = n)
     sd[i,] <-  c(n, cum$stderr, cum$CV)
     meanh[i,] <- c(n, cum$meanh)
     varh[i,] <-  c(n, cum$varh)
     i <- i + 1
  }
colnames(sd) <- c("n", "sderr", "CV")
colnames(meanh) <- c("nclass", paste0(rep("Strata", 5), 1:5))
colnames(varh) <- c("nclass", paste0(rep("Strata", 5), 1:5))
end.time <- Sys.time()
time.taken <- round(end.time - start.time, 2)
time.taken
```

```{r, echo = FALSE}
#saveRDS(sd, file = paste0(here::here(), "/Output/sd.RDS"))
sd <- readRDS(file = paste0(here::here(), "/Output/sd.RDS"))
```

#### Número óptimo de clases {-}

Se toma cada matriz resultante de errores estándar de la lista `stderr`, y luego selecciona la fila que tiene el coeficiente de variación (`CV`) más bajo. Estos resultados se almacenan en la lista `min.strata`, la cual contendrá los data.frames correspondientes a las filas con el menor `CV `para cada uno de los tres conjuntos de datos en `stderr`.  

```{r}
min.strata <- sd %>%
               as.data.frame() %>% 
                slice(which.min(.$CV)) 
```

```{r, echo = FALSE}
tabla <- min.strata %>%
          dplyr::mutate(ANIO = "2020") %>%
           relocate(ANIO, .before = "n")

tabla %>% 
 rename("AÑO" = "ANIO") %>%
  gt() %>%
   tab_header(title = "Número óptimo de clases") %>%
    fmt_integer(columns = names(tabla)[2]) %>%
     fmt_number(columns = names(tabla)[3:4],
                decimals = 2) %>%
       tab_options(heading.title.font.size = 14, 
                   heading.subtitle.font.size = 12,
                   table.font.names = 'Century Gothic',
                   table.align = "center",
                   table.font.size = 10) %>%
        tab_style(style = list(cell_text(align = "left",
                                          weight = 'bold')),
                   locations = list(cells_title(groups = c("title")))) %>%
         tab_style(style = list(cell_text(align = "left")),
                    locations = list(cells_title(groups = c("subtitle")))) %>%
          cols_label(AÑO = md("**AÑO**"),
                     n = md("**n**"),
                     sderr = md("**sd**"),
                     CV = md("**C.V.**")) %>%
           as_raw_html() 
```



```{r, echo = FALSE, results=FALSE, out.width='80%'}
p <- sd %>%
      as.data.frame() %>% 
       na.omit() %>%
        arrange(desc(.$CV)) %>%
         ggplot() + 
          geom_point(aes(x = seq(1, nrow(sd %>% na.omit())), y = CV)) + 
           geom_line(aes(x = seq(1, nrow(sd %>% na.omit())), y = CV)) +
            geom_hline(data = min.strata, aes (yintercept = CV), color = "red") +
             geom_text(data = min.strata, aes(label = paste0("CV = ", round(CV, 4)), x = iteraciones - 75, y = CV),  
                       vjust = -1,
                        size = 6,
                         color = "red",
                          family = "Century Gothic") +
             geom_hline(data = min.strata, aes(yintercept = CV), color = "red") +
              theme_minimal() + 
               theme(title = element_text(family = "Century Gothic"), 
                      plot.title = element_text(size = 22, family = "Century Gothic"),
                          plot.subtitle = element_text(size = 20, family = "Century Gothic"),
                          axis.text = element_text(size = 14, family = "Century Gothic"),
                          axis.title = element_text(size = 18, family = "Century Gothic")) + 
                     scale_y_continuous(labels = scales::number_format(accuracy = 0.01)) +
                 labs(title = "Coeficiente de variación óptimo",
                       subtitle = '2020',
                        y = "CV", 
                         x = "iteraciones") 
```


<a href="https://raw.githubusercontent.com/dvillasanao/IMC_2020/main/img/iteraciones.png" data-lightbox="image-1" data-title="iteraciones">
```{r, echo = FALSE, fig.width=12, fig.height=12, out.width='100%'}
knitr::include_graphics(paste0(here::here(), "/img/iteraciones.png"))
```
</a>

Se toman en cuenta el número de clases que salen del los resultados del método iterativo. Utilizando la función `strata.cumrootf()` de la paquetería `stratification` con parámetros específicos y el número de clases (`nclass`) obtenido de `min.strata`.       
- `CV = 0.05`: Establece el coeficiente de variación.   
- `Ls = 5`: Establece el número de estratos.   
- `alloc = c(0.5, 0, 0.5)`: Define la asignación para la estratificación.    
- `nclass = min.strata[,1]`: Establece el número de clases utilizando el primer valor de la fila con el menor CV en `min.strata`.  

```{r}
strata.DP2 <- strata.cumrootf(DP2_2020[,25], 
                               CV = 0.01, 
                                Ls = 5, 
                                 alloc = c(0.5, 0, 0.5), 
                                  nclass = min.strata[,1])
```

Se agregan los datos a la base original

```{r}
##Se agrega a la base DP2
DP2_2020 <- data.frame(DP2_2020 %>% 
                        select(-IM_out), ## Se elimina el índice ficticio
                         strata.DP2[["stratumID"]])

# Se cambian los nombres de las columnas 
names(DP2_2020) <- c(names(DP2_2020)[1:23],
                      paste0("IM_2020"), paste0("GM_2020"))

# Se cambian los levels a los grados de marginación correspondientes
levels(DP2_2020[,25]) = c("Muy alto", "Alto", "Medio", "Bajo", "Muy bajo")
```


### Límites de los estratos {-}

Se crea un data frame llamado `limites` que contiene los límites de ciertos intervalos para el año `2020`. Cada columna contiene una combinación de:   
- El valor mínimo del índice de marginación (`IM:`) para el año correspondiente.  
- Los valores de los límites de los estratos (`bh`) calculados previamente.  
- El valor máximo del índice de marginación (`IM_`) para el año correspondiente.  

```{r}
limites <- data.frame("2020" = c(min(DP2_2020$IM_2020), strata.DP2$bh, max(DP2_2020$IM_2020)))
```


```{r, echo = FALSE}
tabla <- limites %>%
          t()  %>%
           as.data.frame() %>%
            mutate_if(is.numeric, round, digits = 2) %>%
             tibble::rownames_to_column(.data = .) %>% 
              mutate(ANIO = c("2020"),
                     `Muy alto` = paste("[", V1, "-", V2, "]"),
                     `Alto` = paste("(", V2, "-", V3, "]"),
                     `Medio` = paste("(", V3, "-", V4, "]"),
                     `Bajo` = paste("(", V4, "-", V5, "]"),
                     `Muy bajo` = paste("(", V5, "-", V6, "]")) %>%
               select(., c(8:13))

tabla %>% 
 rename("AÑO" = "ANIO") %>%
  gt(rowname_col = c("AÑO")) %>%
   tab_header(title = "Límite de los estratos") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10) %>%
     tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
      cols_label(AÑO = md("**AÑO**"), 
                 `Muy alto` = md("**Muy alto**"),
                 `Alto` = md("**Alto**"),
                 `Medio` = md("**Medio**"),
                 `Bajo` = md("**Bajo**"),
                 `Muy bajo` = md("**Muy bajo**")) %>%
      as_raw_html() 
```



<!--chapter:end:05-Estratificacion.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Índice normalizado  {.unlisted .unnumbered}

Otra forma de apreciar el índice de marginación es normalizando sus valores para ver objetivamente la evolución de cada unidad territorial (Somarriba et al. 2013). La normalización se realiza utilizando un cambio de escala conocido como normalización mínima-máxima. Con este procedimiento el índice de marginación se escala a valores relativos con un rango de entre cero y uno, lo cual permite su comparación numérica y le da una propiedad adicional al índice de marginación. Al mismo tiempo, la normalización determina el mismo sentido que el índice obtenido por el método DP2, donde los valores cercanos a cero implican mayor marginación.  

El proceso de normalización consiste en:

$${DP}_2normalizado=\frac{{DP}_2^i-\min({DP}_2)}{\max({DP}_2)-\min({DP}_2)},$$
donde:

$\circ \: {DP}_{2}^{i}$: es el valor del índice de marginación de la localidad $i$,   
$\circ \: min ({DP}_{2})$: es el valor mínimo o peor escenario que puede tomar el índice, y   
$\circ \: max ({DP}_{2})$: es el valor máximo u objetivo que puede tomar el índice.  


## Desviación estándar de los indicadores simples  {-}

**Varianza muestral insesgada**    
**Estimado insesgado de la varianza poblacional**      

$$s^{2} = \frac{1}{n-1}\left(x_{i}-\bar{x}\right)^{2} = \frac{\sum_{i=1}^{n}(x_{i}^{2})}{n-1} - \frac{\sum_{i=1}^{n}(x_{i})^{2}}{(n-1)\: n } = \left(\frac{n-1}{n}\right)s_{n}^{2} $$

Se calcula la desviación estándar muestral y su inversa para un conjunto de indicadores simples. Para cada elemento:   
- Extrae las columnas 13 a 23 del data frame correspondiente (`DP2_2020`).  
- Calcula la desviación estándar para cada una de estas columnas.  
- Ajusta la desviación estándar para obtener la desviación estándar muestral.  
- Calcula la inversa de la desviación estándar muestral.  
- Almacena los resultados en un data frame `desvest`. 

```{r}
# Desviación estandar de los indicadores
desvest <- as.matrix(apply(DP2_2020[13:23], MARGIN = 2, sd)) %>%
            as.data.frame() %>%
             rename("desvest" = "V1") %>%
              mutate(sd_muestral = .$desvest * (sqrt((dim(DP2_2020[13:23])[1] - 1)/dim(DP2_2020[13:23])[1]))) %>%
               mutate(desvest.inversa = 1/(.$sd_muestral))

```


```{r, echo = FALSE}
# Tabla
tabla <- desvest %>%
          tibble::rownames_to_column()

tabla %>%
 gt() %>%
  tab_header(title = "Desviación estándar") %>% 
   tab_options(heading.title.font.size = 14, 
               heading.align = "center",
               heading.padding = 5,
               heading.subtitle.font.size = 12,
               table.align = "center",
               table.font.names = 'Century Gothic',
               table.font.size = 10,
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "center",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     cols_label(`desvest` = md("**Desviación estándar**"), 
                `sd_muestral` = md("**Desviación estándar  muestral**"),
                `desvest.inversa` = md("**Desviación estandar m. inversa**")) %>%
      fmt_number(columns = c(2:4), decimals = 3) %>%
      as_raw_html()
```

## Escenarios extremos {-}

Para este tipo de cálculo es necesario conocer los puntos más extremos que puede tomar el índice en el año de observación. De antemano, se sabe que cada indicador simple toma valores de cero a 100 y, además, el método DP2 ya proporcionó el orden de entrada de las variables. Usando estos criterios se estiman los puntos focales extremos que puede tomar el índice de marginación. Se sabe que la peor situación es cuando una unidad de análisis toca todos y cada uno de los valores mínimos del vector base de referencia común, esto sería el peor escenario de marginación y tomaría un valor de cero. En sentido contrario, el valor máximo sería la situación con la menor marginación.   

**Escenarios del mínimo y máximo valor en el índice DP2**  

Se calculan los valores mínimo y máximo del índice `DP2` para diferentes escenarios y años. Para cada elemento, se calcula:   
- `Valor mínimo`: Calcula la diferencia absoluta entre minRV_2010 y vector_minimo, ajusta con la inversa de la desviación estándar muestral y los factores de corrección, y suma las filas para obtener el DP2.   
- `Valor máximo`: Calcula la diferencia absoluta entre minRV_2010 y un vector de ceros (vector_maximo), ajusta con la inversa de la desviación estándar muestral y los factores de corrección, y suma las filas para obtener el DP2.    


```{r}
## Mínimo valor del DP2
vector_minimo <- minRV_2020
minimo <- abs(vector_minimo - minRV_2020) * desvest$desvest.inversa *
           ind_2020$correction_factors[names(DP2_datos_2020)] %>%
            t() %>%
             as.data.frame() 

minimo <- data.frame(AÑO = 2020, Escenario = "Mínimo", minimo, DP2 = rowSums(minimo))
  
## Máximo valor del DP2   
vector_maximo <- rep(0, length(minRV_2020)) # Cuando los indicadores valen cero 
maximo <- abs(vector_maximo - minRV_2020) * desvest$desvest.inversa *
           ind_2020$correction_factors[names(DP2_datos_2020)] %>%
            t() %>%
             as.data.frame() 
maximo <- data.frame(AÑO = 2020, Escenario = "Máximo", maximo, DP2 = rowSums(maximo))
```


## Índice normalizado {-}

**Se guarda la base de datos con el índice normalizado**   

Se calcula un nuevo indicador denominado `IMN para el año `2020`, normalizando el índice DP2 entre sus valores mínimos y máximos.    

```{r}
DP2_2020 <- DP2_2020 %>%  
             mutate(IMN_2020 = (.$IM_2020 - minimo$DP2)/(maximo$DP2 - minimo$DP2))
```


::: {style="height:400px;overflow:auto;"}
```{r, echo=FALSE}
#Tabla final
DP2_2020 %>% 
 rename("AÑO" = "ANIO") %>%
  slice(1:20) %>%
  gt() %>%
   tab_header(title = "Índice de marginación a nivel colonia, 2020") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                column_labels.font.weight = "bold",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
      fmt_integer(columns = "POB_TOT", sep_mark = " ") %>%
       fmt_number(columns = c(13:23), decimals = 1) %>%
        fmt_number(columns = c(24, 26), decimals = 3) %>%
         cols_width(starts_with("POB") ~ px(100), 
                    starts_with("NOM") ~ px(200), 
                    starts_with("NOM_COLONIA") ~ px(260), 
                    everything() ~ px(60)) %>%
           as_raw_html()
```
:::



 
 <\br>
```{r, eval = FALSE}
#Tabla final
save(DP2_2020, file = paste0(here::here(), "/Output/IMC_2020.RData"))
```


<!--chapter:end:06_Normalizacion.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Validación de datos  {.unlisted .unnumbered}

## Orden de entrada de las variables  {-}

**Se crea un data.frame de acuerdo al orden de importancia de las variables**   

Dependiendo del proceso, el `DP2` adoptará diferentes valores. Por lo tanto, es importante que el método de como resultado un orden de entrada único de los indicadores parciales.     

```{r}
Variables_sort <- ind_2020$variables_sort
```

```{r, echo = FALSE}
tabla <- Variables_sort %>%
          as.data.frame() %>%
           rename("Ind_2020" = ".")

tabla %>%
 gt() %>%
  tab_header(title = "Variables sort") %>%
   tab_options(heading.title.font.size = 14, 
               heading.align = "center",
               heading.subtitle.font.size = 12,
               table.align = "center",
               table.font.names = 'Century Gothic',
               table.font.size = 10,
               data_row.padding = px(1)) %>%
    tab_style(style = list(cell_text(align = "center",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
      cols_width(everything() ~ px(80)) %>%
       as_raw_html() 
```


## Coeficiente de correlación {-}  

El coeficiente de correlación es una medida que se utiliza para jerarquizar a los indicadores simples de acuerdo con el grado de correlación absoluta con respecto al indicador sintético resultante, es decir, ayuda a visualizar que variable tiene un mejor o peor apego con el fenómeno.       

**Se crea un data.frame de acuerdo a la correlación de cada variable con el indicador sintético (DP2)**   

```{r}
cor.coeff <- ind_2020$cor.coeff
colnames(cor.coeff) <- c("cor.coeff")
```


```{r, echo = FALSE}
tabla <- cor.coeff %>%
          as.data.frame() %>%
          tibble::rownames_to_column(var = "Ind_2020")

tabla %>%
  gt() %>%
   tab_header(title = "Correlation Coefficient") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       fmt_number(columns = c(2), decimals = 3) %>% 
        cols_label(`Ind_2020` = md("**Ind_2020**"), 
                   `cor.coeff` = md("**cor.coeff**")) %>%
          cols_width(everything() ~ px(80)) %>%
           as_raw_html()           
```

## Factor de corrector  {-}

El factor corrector, como se mencionó anteriormente, indica la proporción de información con la que contribuye el indicador simple al nuevo índice sintético, además, evita la duplicidad e incorpora información útil que retiene cada indicador simple.        

**Se crea un data.frame de acuerdo al factor corrector de cada indicador parcial**

```{r}
correction_factors <- ind_2020$correction_factors %>% 
                       as.data.frame() %>%
                        rename("Correction Factor" = ".")
```


```{r, echo = FALSE}
tabla <- correction_factors %>%
          as.data.frame() %>%
           tibble::rownames_to_column(var = "Ind_2020")

tabla %>%
  gt() %>%
   tab_header(title = "Correction Factors") %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       fmt_number(columns = c(2), decimals = 3) %>% 
        cols_label(`Ind_2020` = md("**Ind_2020**"), 
                   `Correction Factor` = md("**Correction Factor**")) %>%                      
         cols_width(everything() ~ px(80)) %>%
          as_raw_html()        
```


## Coeficiente de Discriminación  {-}

El coeficiente de discriminación de Ivanovic mide el poder discriminante de la variable $j$ en el conjunto de observaciones $i$. 

$$CD_{j}=\frac{2}{m\left(m-1\right)}\sum_{i,l>i}^{k_{j}}m_{ij}m_{lj}\left|\frac{x_{ij}-x_{lj}}{{\overline{X}}_{i}}\right|$$

donde: 

$\circ\:m_{ij}$: El número de observaciones de la variable $x_{j}$    
$\circ\:k_{j}$: El número de diferentes valores que toma $x_{i}$ en el conjunto $j$.     


Esta medida está comprendida entre $[0, 2]$. Si una variable toma el mismo valor para todos los estados, el `CD` vale cero, indicando que posee un valor nulo de poder discriminante. Por el contrario, si una variable toma el valor teórico de máximo poder discriminante, el discriminante de la variable es total.   

**Se crea un data.frame de acuerdo al Coeficiente de discriminación (CD) de cada indicador parcial**

```{r}
discrimination_coefficient <- ind_2020$discrimination.coefficient %>% 
                               as.data.frame() %>%
                                rename("Discrimination Coefficient" = ".")
```


```{r, echo = FALSE}
tabla <- discrimination_coefficient %>%
          as.data.frame() %>%
           tibble::rownames_to_column(var = "Ind_2020")
tabla %>%
 gt() %>%
  tab_header(title = "Discrimination Coefficient") %>%
   tab_options(heading.title.font.size = 14, 
               heading.align = "center",
               heading.subtitle.font.size = 12,
               table.align = "center",
               table.font.names = 'Century Gothic',
               table.font.size = 10,
               data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       fmt_number(columns = c(2), decimals = 3) %>% 
        cols_label(`Ind_2020` = md("**Ind_2020**"),
                   `Discrimination Coefficient` = md("**Discrimination Coefficient**")) %>%
         cols_width(everything() ~ px(80)) %>%
          as_raw_html()         
```

## “Cantidad de Información Global de Ivanovic Pena Relativa Individual” {-}

$$\alpha_{i}=\frac{CD_{i}\left(1-R^{2}_{i,i-1,...,1} \right)}{\sum_{i=1}^{n}CD_{i} \left(1-R^{2}_{i,i-1,...,1} \right)}$$
Esta medida, comprendida entre 0 y 1, combina la información útil y el poder discriminante de cada indicador simple y mide la cantidad de información (combinada) relativa que aporta individualmente cada indicador simple, cuando entra de forma ordenada a formar parte del indicador sintético DP2. La suma de todos los valores de $\alpha_{i}$ es la unidad. [Zarsosa 1996, págs 158-174]      

```{r}
alpha <- correction_factors * discrimination_coefficient/sum(correction_factors * discrimination_coefficient)
colnames(alpha) <- c("alpha")
```

```{r, echo = FALSE}
tabla <- alpha %>%
          as.data.frame() %>%
           tibble::rownames_to_column(var = "Ind_2020")

tabla %>%
  gt() %>%
   tab_header(title = md("Cantidad de Información Global de Ivanovic Pena Relativa Individual")) %>%
    tab_options(heading.title.font.size = 14, 
                heading.align = "center",
                heading.subtitle.font.size = 12,
                table.align = "center",
                table.font.names = 'Century Gothic',
                table.font.size = 10,
                data_row.padding = px(1)) %>%
      tab_style(style = list(cell_text(align = "center",
                                       weight = 'bold')),
                locations = list(cells_title(groups = c("title")))) %>%
       fmt_number(columns = c(2), decimals = 3) %>% 
       cols_label(`Ind_2020` = md("**Ind_2020**"),
                  `alpha` = md("**alpha**")) %>%
         cols_width(everything() ~ px(80)) %>%
          as_raw_html()        
```


<!--chapter:end:07-Validacion.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Resumen  {.unlisted .unnumbered}

```{r, echo = FALSE}
load(file = paste0(here::here(), "/Output/IMC_2020.RData"))

p <- DP2_2020 %>%
      group_by(GM_2020) %>%
       summarise(POB_TOT = sum(POB_TOT),
                 GM = n())

tabla <- p %>%
          janitor::adorn_totals(fill = "-", where = "row")

tabla %>% 
 gt() %>%
  tab_header(title = "Nacional: Población y unidades geograficas según el índice de marginación, 2020") %>%
   tab_options(heading.title.font.size = 14, 
               heading.subtitle.font.size = 12,
               table.font.names = 'Century Gothic',
               table.align = "center",
               table.font.size = 10,
               data_row.padding = px(1)) %>%
     tab_style(style = list(cell_text(align = "left",
                                      weight = 'bold')),
               locations = list(cells_title(groups = c("title")))) %>%
     tab_style(style = list(cell_text(align = "left")),
               locations = list(cells_title(groups = c("subtitle")))) %>%
     tab_style(style = list(cell_text(weight = 'bold')),
               locations = cells_body(columns = everything(), rows = tidyselect::last_col())) %>%
      cols_label(`POB_TOT` = md("**Población 2020**"),
                 `GM` = md("**Colonias**"),
                 `GM_2020` = md("**Grados**")) %>%
       fmt_integer(columns = c(2:3), sep_mark = " ") %>%
        tab_spanner(label = "2020",
                    columns = c(2:3)) %>%
         as_raw_html() 
```



## Mapa a nivel colonia {-}


```{r, echo=FALSE, out.width='100%', warning=FALSE, message=FALSE, eval = FALSE}
p <- readRDS(file = paste0(here::here(),"/Output/Mapa.rds"))
p
```


## Comparación en el tiempo {-}

<div style="height:500px;">
```{r, echo=FALSE, out.width='100%', eval = FALSE}
readRDS(paste0(here::here(), "/Output/Mapas_2010-2020.rds"))
```
</div> 

<!--chapter:end:08-Resumen.Rmd-->

```{r include=FALSE, cache=FALSE}
# example R options set globally
options(width = 80)

# example chunk options set globally
knitr::opts_chunk$set(
  comment = "#>",
  collapse = TRUE,
  message = FALSE,
  warning = FALSE
  )
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())

```
# Referencias  {.unlisted .unnumbered}

```{r echo = FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
setwd(here::here())
``` 

Dalenius, T. (1950). The problem of optimum stratification. Scandinavian Actuarial J., 3-4, 203-13. Recuperado de: https://doi.org/10.1080/03461238.1950.10432042    
__________ y Hodges, J. L., Jr. (1959). Minimum variance stratification. Journal of the American Statistical Association, 54, 88-101.      
Gunning, P. y Horgan, J. M. (2004). A new algorithm for the construction of stratum boundaries in skewed populations. Survey Methodology, 30 (2), 159–166.   

INEGI [Instituto Nacional de Estadística y Geografía]. (2009). Censo de Población y Vivienda 2010. Manual de
cartografía geoestadística. Recuperado de: https://www.inegi.org.mx/contenidos/temas/mapas/mg/metadatos/manual_cartografia_censal.pdf   
__________. (2010). Sistema Nacional de Información Estadística y Geográfica: Laboratorio de Microdatos. Censo
de Población y Vivienda 2010.   
__________. (2021a). Sistema Nacional de Información Estadística y Geográfica: Laboratorio de Microdatos. Censo
de Población y Vivienda 2020.    
__________. (2021b). Marco Geoestadístico Nacional 2020. Censo de Población y Vivienda 2020. Recuperado de:
https://www.inegi.org.mx/app/biblioteca/ficha.html?upc=889463807469    

Pena Trapero, J. B. (1977). Problemas de la medición del bienestar y conceptos afines. Una aplicación al Caso Español. I. N. E: Madrid.   

Somarriba, N. y Pena, B. (2009). Synthetic Indicators of Quality of Life in Europe. Social Indicators Research. Recuperado de: https://doi.org/10.1007/s11205-008-9356-y    
__________, Zarzosa, P. y Pena, T. (2013). La calidad de vida en la Unión Europea. Un análisis temporal por medio de indicadores sintéticos.    Congreso de la Asociación Española de Ciencia Regional. XXXIX Reunión de Estudios Regionales. Smart regions for a smarter growth strategy: new challenges of Regional Policy and potentials of cities to overcome a worldwide economic crisis. Recuperado de:  https://old.reunionesdeestudiosregionales.org/Oviedo2013/htdocs/pdf/p851.pdf     

Zarzosa, P. (1996). Aproximación a la medición del bienestar social. Secretario de Publicaciones: Valladolid.    
__________. (2009). Estimación de la pobreza en las comunidades autónomas españolas, mediante la distancia DP2 de Pena. Estudios de Economía Aplicada, 27 (2), 397–416.
__________. (2012). The Social Welfare in Spain before the Crisis: Territorial and Chronological Analysis. International Journal of Advances in Management and Economics 1 (4), 165-171.   
__________ y Somarriba, N. (2013). An Assessment of Social Welfare in Spain: Territorial Analysis Using a Synthetic Welfare Indicator. Social Indicators Research, 111, 1-23.    

 

```{r, collapse=FALSE}
sesion_info <- devtools::session_info()
```


```{r, echo = FALSE}
kable(dplyr::select(tibble::as_tibble(sesion_info$packages %>% dplyr::filter(attached == TRUE)),
                    c(package, loadedversion, source))) %>%
   kable_classic(full_width = TRUE, html_font = "Century Gothic", font_size = 10) 
```

<!--chapter:end:09-Bibliografias.Rmd-->

